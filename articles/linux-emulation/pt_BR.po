#$FreeBSD$
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2018-08-12 23:11+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: pt_BR\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=iso-8859-1\n"
"Content-Transfer-Encoding: 8bit\n"

#. Put one translator per line, in the form NAME <EMAIL>, YEAR1, YEAR2
msgctxt "_"
msgid "translator-credits"
msgstr ""

#. (itstool) path: info/title
#: article.translate.xml:7
msgid "<trademark class=\"registered\">Linux</trademark> emulation in FreeBSD"
msgstr ""

#. (itstool) path: affiliation/address
#: article.translate.xml:15
#, no-wrap
msgid ""
"\n"
"\t  <email>rdivacky@FreeBSD.org</email>\n"
"\t"
msgstr ""

#. (itstool) path: info/author
#: article.translate.xml:9
msgid "<personname> <firstname>Roman</firstname> <surname>Divacky</surname> </personname> <affiliation> <_:address-1/> </affiliation>"
msgstr ""

#. (itstool) path: legalnotice/para
#: article.translate.xml:22
msgid "Adobe, Acrobat, Acrobat Reader, Flash and PostScript are either registered trademarks or trademarks of Adobe Systems Incorporated in the United States and/or other countries."
msgstr ""

#. (itstool) path: legalnotice/para
#: article.translate.xml:26
msgid "IBM, AIX, OS/2, PowerPC, PS/2, S/390, and ThinkPad are trademarks of International Business Machines Corporation in the United States, other countries, or both."
msgstr ""

#. (itstool) path: legalnotice/para
#: article.translate.xml:30
msgid "FreeBSD is a registered trademark of the FreeBSD Foundation."
msgstr ""

#. (itstool) path: legalnotice/para
#: article.translate.xml:32
msgid "Linux is a registered trademark of Linus Torvalds."
msgstr ""

#. (itstool) path: legalnotice/para
#: article.translate.xml:34
msgid "NetBSD is a registered trademark of the NetBSD Foundation."
msgstr ""

#. (itstool) path: legalnotice/para
#: article.translate.xml:36
msgid "RealNetworks, RealPlayer, and RealAudio are the registered trademarks of RealNetworks, Inc."
msgstr ""

#. (itstool) path: legalnotice/para
#: article.translate.xml:39
msgid "Oracle is a registered trademark of Oracle Corporation."
msgstr ""

#. (itstool) path: legalnotice/para
#: article.translate.xml:41
msgid "Sun, Sun Microsystems, Java, Java Virtual Machine, JDK, JRE, JSP, JVM, Netra, OpenJDK, Solaris, StarOffice, SunOS and VirtualBox are trademarks or registered trademarks of Sun Microsystems, Inc. in the United States and other countries."
msgstr ""

#. (itstool) path: legalnotice/para
#: article.translate.xml:46
msgid "Many of the designations used by manufacturers and sellers to distinguish their products are claimed as trademarks. Where those designations appear in this document, and the FreeBSD Project was aware of the trademark claim, the designations have been followed by the <quote>™</quote> or the <quote>®</quote> symbol."
msgstr ""

#. (itstool) path: info/pubdate
#. (itstool) path: info/releaseinfo
#: article.translate.xml:54
#: article.translate.xml:56
msgid "$FreeBSD: head/en_US.ISO8859-1/articles/linux-emulation/article.xml 51904 2018-06-23 14:55:54Z bcr $"
msgstr ""

#. (itstool) path: abstract/para
#: article.translate.xml:59
msgid "This masters thesis deals with updating the <trademark class=\"registered\">Linux</trademark> emulation layer (the so called <firstterm>Linuxulator</firstterm>). The task was to update the layer to match the functionality of <trademark class=\"registered\">Linux</trademark> 2.6. As a reference implementation, the <trademark class=\"registered\">Linux</trademark> 2.6.16 kernel was chosen. The concept is loosely based on the NetBSD implementation. Most of the work was done in the summer of 2006 as a part of the Google Summer of Code students program. The focus was on bringing the <firstterm>NPTL</firstterm> (new <trademark class=\"registered\">POSIX</trademark> thread library) support into the emulation layer, including <firstterm>TLS</firstterm> (thread local storage), <firstterm>futexes</firstterm> (fast user space mutexes), <firstterm>PID mangling</firstterm>, and some other minor things. Many small problems were identified and fixed in the process. My work was integrated into the main FreeBSD source repository and will be shipped in the upcoming 7.0R release. We, the emulation development team, are working on making the <trademark class=\"registered\">Linux</trademark> 2.6 emulation the default emulation layer in FreeBSD."
msgstr ""

#. (itstool) path: sect1/title
#: article.translate.xml:82
msgid "Introduction"
msgstr ""

#. (itstool) path: sect1/para
#: article.translate.xml:84
msgid "In the last few years the open source <trademark class=\"registered\">UNIX</trademark> based operating systems started to be widely deployed on server and client machines. Among these operating systems I would like to point out two: FreeBSD, for its BSD heritage, time proven code base and many interesting features and <trademark class=\"registered\">Linux</trademark> for its wide user base, enthusiastic open developer community and support from large companies. FreeBSD tends to be used on server class machines serving heavy duty networking tasks with less usage on desktop class machines for ordinary users. While <trademark class=\"registered\">Linux</trademark> has the same usage on servers, but it is used much more by home based users. This leads to a situation where there are many binary only programs available for <trademark class=\"registered\">Linux</trademark> that lack support for FreeBSD."
msgstr ""

#. (itstool) path: sect1/para
#: article.translate.xml:98
msgid "Naturally, a need for the ability to run <trademark class=\"registered\">Linux</trademark> binaries on a FreeBSD system arises and this is what this thesis deals with: the emulation of the <trademark class=\"registered\">Linux</trademark> kernel in the FreeBSD operating system."
msgstr ""

#. (itstool) path: sect1/para
#: article.translate.xml:103
msgid "During the Summer of 2006 Google Inc. sponsored a project which focused on extending the <trademark class=\"registered\">Linux</trademark> emulation layer (the so called Linuxulator) in FreeBSD to include <trademark class=\"registered\">Linux</trademark> 2.6 facilities. This thesis is written as a part of this project."
msgstr ""

#. (itstool) path: sect1/title
#: article.translate.xml:110
msgid "A look inside…"
msgstr ""

#. (itstool) path: sect1/para
#: article.translate.xml:112
msgid "In this section we are going to describe every operating system in question. How they deal with syscalls, trapframes etc., all the low-level stuff. We also describe the way they understand common <trademark class=\"registered\">UNIX</trademark> primitives like what a PID is, what a thread is, etc. In the third subsection we talk about how <trademark class=\"registered\">UNIX</trademark> on <trademark class=\"registered\">UNIX</trademark> emulation could be done in general."
msgstr ""

#. (itstool) path: sect2/title
#: article.translate.xml:120
msgid "What is <trademark class=\"registered\">UNIX</trademark>"
msgstr ""

#. (itstool) path: sect2/para
#: article.translate.xml:122
msgid "<trademark class=\"registered\">UNIX</trademark> is an operating system with a long history that has influenced almost every other operating system currently in use. Starting in the 1960s, its development continues to this day (although in different projects). <trademark class=\"registered\">UNIX</trademark> development soon forked into two main ways: the BSDs and System III/V families. They mutually influenced themselves by growing a common <trademark class=\"registered\">UNIX</trademark> standard. Among the contributions originated in BSD we can name virtual memory, TCP/IP networking, FFS, and many others. The System V branch contributed to SysV interprocess communication primitives, copy-on-write, etc. <trademark class=\"registered\">UNIX</trademark> itself does not exist any more but its ideas have been used by many other operating systems world wide thus forming the so called <trademark class=\"registered\">UNIX</trademark>-like operating systems. These days the most influential ones are <trademark class=\"registered\">Linux</trademark>, Solaris, and possibly (to some extent) FreeBSD. There are in-company <trademark class=\"registered\">UNIX</trademark> derivatives (AIX, HP-UX etc.), but these have been more and more migrated to the aforementioned systems. Let us summarize typical <trademark class=\"registered\">UNIX</trademark> characteristics."
msgstr ""

#. (itstool) path: sect2/title
#. (itstool) path: sect3/title
#: article.translate.xml:143
#: article.translate.xml:312
#: article.translate.xml:491
msgid "Technical details"
msgstr ""

#. (itstool) path: sect2/para
#: article.translate.xml:145
msgid "Every running program constitutes a process that represents a state of the computation. Running process is divided between kernel-space and user-space. Some operations can be done only from kernel space (dealing with hardware etc.), but the process should spend most of its lifetime in the user space. The kernel is where the management of the processes, hardware, and low-level details take place. The kernel provides a standard unified <trademark class=\"registered\">UNIX</trademark> API to the user space. The most important ones are covered below."
msgstr ""

#. (itstool) path: sect3/title
#: article.translate.xml:156
msgid "Communication between kernel and user space process"
msgstr ""

#. (itstool) path: sect3/para
#: article.translate.xml:159
msgid "Common <trademark class=\"registered\">UNIX</trademark> API defines a syscall as a way to issue commands from a user space process to the kernel. The most common implementation is either by using an interrupt or specialized instruction (think of <literal>SYSENTER</literal>/<literal>SYSCALL</literal> instructions for ia32). Syscalls are defined by a number. For example in FreeBSD, the syscall number 85 is the <citerefentry><refentrytitle>swapon</refentrytitle><manvolnum>2</manvolnum></citerefentry> syscall and the syscall number 132 is <citerefentry><refentrytitle>mkfifo</refentrytitle><manvolnum>2</manvolnum></citerefentry>. Some syscalls need parameters, which are passed from the user-space to the kernel-space in various ways (implementation dependant). Syscalls are synchronous."
msgstr ""

#. (itstool) path: sect3/para
#: article.translate.xml:172
msgid "Another possible way to communicate is by using a <firstterm>trap</firstterm>. Traps occur asynchronously after some event occurs (division by zero, page fault etc.). A trap can be transparent for a process (page fault) or can result in a reaction like sending a <firstterm>signal</firstterm> (division by zero)."
msgstr ""

#. (itstool) path: sect3/title
#: article.translate.xml:181
msgid "Communication between processes"
msgstr ""

#. (itstool) path: sect3/para
#: article.translate.xml:183
msgid "There are other APIs (System V IPC, shared memory etc.) but the single most important API is signal. Signals are sent by processes or by the kernel and received by processes. Some signals can be ignored or handled by a user supplied routine, some result in a predefined action that cannot be altered or ignored."
msgstr ""

#. (itstool) path: sect3/title
#: article.translate.xml:192
msgid "Process management"
msgstr ""

#. (itstool) path: sect3/para
#: article.translate.xml:194
msgid "Kernel instances are processed first in the system (so called init). Every running process can create its identical copy using the <citerefentry><refentrytitle>fork</refentrytitle><manvolnum>2</manvolnum></citerefentry> syscall. Some slightly modified versions of this syscall were introduced but the basic semantic is the same. Every running process can morph into some other process using the <citerefentry><refentrytitle>exec</refentrytitle><manvolnum>3</manvolnum></citerefentry> syscall. Some modifications of this syscall were introduced but all serve the same basic purpose. Processes end their lives by calling the <citerefentry><refentrytitle>exit</refentrytitle><manvolnum>2</manvolnum></citerefentry> syscall. Every process is identified by a unique number called PID. Every process has a defined parent (identified by its PID)."
msgstr ""

#. (itstool) path: sect3/title
#: article.translate.xml:208
msgid "Thread management"
msgstr ""

#. (itstool) path: sect3/para
#: article.translate.xml:210
msgid "Traditional <trademark class=\"registered\">UNIX</trademark> does not define any API nor implementation for threading, while <trademark class=\"registered\">POSIX</trademark> defines its threading API but the implementation is undefined. Traditionally there were two ways of implementing threads. Handling them as separate processes (1:1 threading) or envelope the whole thread group in one process and managing the threading in userspace (1:N threading). Comparing main features of each approach:"
msgstr ""

#. (itstool) path: sect3/para
#: article.translate.xml:219
msgid "1:1 threading"
msgstr ""

#. (itstool) path: listitem/para
#: article.translate.xml:223
msgid "- heavyweight threads"
msgstr ""

#. (itstool) path: listitem/para
#: article.translate.xml:226
msgid "- the scheduling cannot be altered by the user (slightly mitigated by the <trademark class=\"registered\">POSIX</trademark> API)"
msgstr ""

#. (itstool) path: listitem/para
#: article.translate.xml:230
msgid "+ no syscall wrapping necessary"
msgstr ""

#. (itstool) path: listitem/para
#: article.translate.xml:233
msgid "+ can utilize multiple CPUs"
msgstr ""

#. (itstool) path: sect3/para
#: article.translate.xml:237
msgid "1:N threading"
msgstr ""

#. (itstool) path: listitem/para
#: article.translate.xml:241
msgid "+ lightweight threads"
msgstr ""

#. (itstool) path: listitem/para
#: article.translate.xml:244
msgid "+ scheduling can be easily altered by the user"
msgstr ""

#. (itstool) path: listitem/para
#: article.translate.xml:248
msgid "- syscalls must be wrapped"
msgstr ""

#. (itstool) path: listitem/para
#: article.translate.xml:251
msgid "- cannot utilize more than one CPU"
msgstr ""

#. (itstool) path: sect2/title
#: article.translate.xml:258
msgid "What is FreeBSD?"
msgstr ""

#. (itstool) path: sect2/para
#: article.translate.xml:260
msgid "The FreeBSD project is one of the oldest open source operating systems currently available for daily use. It is a direct descendant of the genuine <trademark class=\"registered\">UNIX</trademark> so it could be claimed that it is a true <trademark class=\"registered\">UNIX</trademark> although licensing issues do not permit that. The start of the project dates back to the early 1990's when a crew of fellow BSD users patched the 386BSD operating system. Based on this patchkit a new operating system arose named FreeBSD for its liberal license. Another group created the NetBSD operating system with different goals in mind. We will focus on FreeBSD."
msgstr ""

#. (itstool) path: sect2/para
#: article.translate.xml:271
msgid "FreeBSD is a modern <trademark class=\"registered\">UNIX</trademark>-based operating system with all the features of <trademark class=\"registered\">UNIX</trademark>. Preemptive multitasking, multiuser facilities, TCP/IP networking, memory protection, symmetric multiprocessing support, virtual memory with merged VM and buffer cache, they are all there. One of the interesting and extremely useful features is the ability to emulate other <trademark class=\"registered\">UNIX</trademark>-like operating systems. As of December 2006 and 7-CURRENT development, the following emulation functionalities are supported:"
msgstr ""

#. (itstool) path: listitem/para
#: article.translate.xml:283
msgid "FreeBSD/i386 emulation on FreeBSD/amd64"
msgstr ""

#. (itstool) path: listitem/para
#: article.translate.xml:286
msgid "FreeBSD/i386 emulation on FreeBSD/ia64"
msgstr ""

#. (itstool) path: listitem/para
#: article.translate.xml:289
msgid "<trademark class=\"registered\">Linux</trademark>-emulation of <trademark class=\"registered\">Linux</trademark> operating system on FreeBSD"
msgstr ""

#. (itstool) path: listitem/para
#: article.translate.xml:293
msgid "NDIS-emulation of Windows networking drivers interface"
msgstr ""

#. (itstool) path: listitem/para
#: article.translate.xml:297
msgid "NetBSD-emulation of NetBSD operating system"
msgstr ""

#. (itstool) path: listitem/para
#: article.translate.xml:300
msgid "PECoff-support for PECoff FreeBSD executables"
msgstr ""

#. (itstool) path: listitem/para
#: article.translate.xml:303
msgid "SVR4-emulation of System V revision 4 <trademark class=\"registered\">UNIX</trademark>"
msgstr ""

#. (itstool) path: sect2/para
#: article.translate.xml:307
msgid "Actively developed emulations are the <trademark class=\"registered\">Linux</trademark> layer and various FreeBSD-on-FreeBSD layers. Others are not supposed to work properly nor be usable these days."
msgstr ""

#. (itstool) path: sect3/para
#: article.translate.xml:314
msgid "FreeBSD is traditional flavor of <trademark class=\"registered\">UNIX</trademark> in the sense of dividing the run of processes into two halves: kernel space and user space run. There are two types of process entry to the kernel: a syscall and a trap. There is only one way to return. In the subsequent sections we will describe the three gates to/from the kernel. The whole description applies to the i386 architecture as the Linuxulator only exists there but the concept is similar on other architectures. The information was taken from [1] and the source code."
msgstr ""

#. (itstool) path: sect4/title
#: article.translate.xml:326
msgid "System entries"
msgstr ""

#. (itstool) path: sect4/para
#: article.translate.xml:328
msgid "FreeBSD has an abstraction called an execution class loader, which is a wedge into the <citerefentry><refentrytitle>execve</refentrytitle><manvolnum>2</manvolnum></citerefentry> syscall. This employs a structure <literal>sysentvec</literal>, which describes an executable ABI. It contains things like errno translation table, signal translation table, various functions to serve syscall needs (stack fixup, coredumping, etc.). Every ABI the FreeBSD kernel wants to support must define this structure, as it is used later in the syscall processing code and at some other places. System entries are handled by trap handlers, where we can access both the kernel-space and the user-space at once."
msgstr ""

#. (itstool) path: sect4/title
#: article.translate.xml:343
#: article.translate.xml:502
msgid "Syscalls"
msgstr ""

#. (itstool) path: sect4/para
#: article.translate.xml:345
msgid "Syscalls on FreeBSD are issued by executing interrupt <literal>0x80</literal> with register <varname>%eax</varname> set to a desired syscall number with arguments passed on the stack."
msgstr ""

#. (itstool) path: sect4/para
#: article.translate.xml:350
msgid "When a process issues an interrupt <literal>0x80</literal>, the <literal>int0x80</literal> syscall trap handler is issued (defined in <filename>sys/i386/i386/exception.s</filename>), which prepares arguments (i.e. copies them on to the stack) for a call to a C function <citerefentry><refentrytitle>syscall</refentrytitle><manvolnum>2</manvolnum></citerefentry> (defined in <filename>sys/i386/i386/trap.c</filename>), which processes the passed in trapframe. The processing consists of preparing the syscall (depending on the <literal>sysvec</literal> entry), determining if the syscall is 32-bit or 64-bit one (changes size of the parameters), then the parameters are copied, including the syscall. Next, the actual syscall function is executed with processing of the return code (special cases for <literal>ERESTART</literal> and <literal>EJUSTRETURN</literal> errors). Finally an <literal>userret()</literal> is scheduled, switching the process back to the users-pace. The parameters to the actual syscall handler are passed in the form of <literal>struct thread *td</literal>, <literal>struct syscall args *</literal> arguments where the second parameter is a pointer to the copied in structure of parameters."
msgstr ""

#. (itstool) path: sect4/title
#. (itstool) path: sect2/title
#: article.translate.xml:376
#: article.translate.xml:548
#: article.translate.xml:1482
msgid "Traps"
msgstr ""

#. (itstool) path: sect4/para
#: article.translate.xml:378
msgid "Handling of traps in FreeBSD is similar to the handling of syscalls. Whenever a trap occurs, an assembler handler is called. It is chosen between alltraps, alltraps with regs pushed or calltrap depending on the type of the trap. This handler prepares arguments for a call to a C function <literal>trap()</literal> (defined in <filename>sys/i386/i386/trap.c</filename>), which then processes the occurred trap. After the processing it might send a signal to the process and/or exit to userland using <literal>userret()</literal>."
msgstr ""

#. (itstool) path: sect4/title
#: article.translate.xml:391
#: article.translate.xml:558
msgid "Exits"
msgstr ""

#. (itstool) path: sect4/para
#: article.translate.xml:393
msgid "Exits from kernel to userspace happen using the assembler routine <literal>doreti</literal> regardless of whether the kernel was entered via a trap or via a syscall. This restores the program status from the stack and returns to the userspace."
msgstr ""

#. (itstool) path: sect4/title
#: article.translate.xml:401
#: article.translate.xml:569
msgid "<trademark class=\"registered\">UNIX</trademark> primitives"
msgstr ""

#. (itstool) path: sect4/para
#: article.translate.xml:403
msgid "FreeBSD operating system adheres to the traditional <trademark class=\"registered\">UNIX</trademark> scheme, where every process has a unique identification number, the so called <firstterm>PID</firstterm> (Process ID). PID numbers are allocated either linearly or randomly ranging from <literal>0</literal> to <literal>PID_MAX</literal>. The allocation of PID numbers is done using linear searching of PID space. Every thread in a process receives the same PID number as result of the <citerefentry><refentrytitle>getpid</refentrytitle><manvolnum>2</manvolnum></citerefentry> call."
msgstr ""

#. (itstool) path: sect4/para
#: article.translate.xml:413
msgid "There are currently two ways to implement threading in FreeBSD. The first way is M:N threading followed by the 1:1 threading model. The default library used is M:N threading (<literal>libpthread</literal>) and you can switch at runtime to 1:1 threading (<literal>libthr</literal>). The plan is to switch to 1:1 library by default soon. Although those two libraries use the same kernel primitives, they are accessed through different API(es). The M:N library uses the <literal>kse_*</literal> family of syscalls while the 1:1 library uses the <literal>thr_*</literal> family of syscalls. Because of this, there is no general concept of thread ID shared between kernel and userspace. Of course, both threading libraries implement the pthread thread ID API. Every kernel thread (as described by <literal>struct thread</literal>) has td tid identifier but this is not directly accessible from userland and solely serves the kernel's needs. It is also used for 1:1 threading library as pthread's thread ID but handling of this is internal to the library and cannot be relied on."
msgstr ""

#. (itstool) path: sect4/para
#: article.translate.xml:434
msgid "As stated previously there are two implementations of threading in FreeBSD. The M:N library divides the work between kernel space and userspace. Thread is an entity that gets scheduled in the kernel but it can represent various number of userspace threads. M userspace threads get mapped to N kernel threads thus saving resources while keeping the ability to exploit multiprocessor parallelism. Further information about the implementation can be obtained from the man page or [1]. The 1:1 library directly maps a userland thread to a kernel thread thus greatly simplifying the scheme. None of these designs implement a fairness mechanism (such a mechanism was implemented but it was removed recently because it caused serious slowdown and made the code more difficult to deal with)."
msgstr ""

#. (itstool) path: sect2/title
#: article.translate.xml:454
msgid "What is <trademark class=\"registered\">Linux</trademark>"
msgstr ""

#. (itstool) path: sect2/para
#: article.translate.xml:456
msgid "<trademark class=\"registered\">Linux</trademark> is a <trademark class=\"registered\">UNIX</trademark>-like kernel originally developed by Linus Torvalds, and now being contributed to by a massive crowd of programmers all around the world. From its mere beginnings to today, with wide support from companies such as IBM or Google, <trademark class=\"registered\">Linux</trademark> is being associated with its fast development pace, full hardware support and benevolent dictator model of organization."
msgstr ""

#. (itstool) path: sect2/para
#: article.translate.xml:464
msgid "<trademark class=\"registered\">Linux</trademark> development started in 1991 as a hobbyist project at University of Helsinki in Finland. Since then it has obtained all the features of a modern <trademark class=\"registered\">UNIX</trademark>-like OS: multiprocessing, multiuser support, virtual memory, networking, basically everything is there. There are also highly advanced features like virtualization etc."
msgstr ""

#. (itstool) path: sect2/para
#: article.translate.xml:471
msgid "As of 2006 <trademark class=\"registered\">Linux</trademark> seems to be the most widely used open source operating system with support from independent software vendors like Oracle, RealNetworks, Adobe, etc. Most of the commercial software distributed for <trademark class=\"registered\">Linux</trademark> can only be obtained in a binary form so recompilation for other operating systems is impossible."
msgstr ""

#. (itstool) path: sect2/para
#: article.translate.xml:478
msgid "Most of the <trademark class=\"registered\">Linux</trademark> development happens in a <application>Git</application> version control system. <application>Git</application> is a distributed system so there is no central source of the <trademark class=\"registered\">Linux</trademark> code, but some branches are considered prominent and official. The version number scheme implemented by <trademark class=\"registered\">Linux</trademark> consists of four numbers A.B.C.D. Currently development happens in 2.6.C.D, where C represents major version, where new features are added or changed while D is a minor version for bugfixes only."
msgstr ""

#. (itstool) path: sect2/para
#: article.translate.xml:488
msgid "More information can be obtained from [3]."
msgstr ""

#. (itstool) path: sect3/para
#: article.translate.xml:493
msgid "<trademark class=\"registered\">Linux</trademark> follows the traditional <trademark class=\"registered\">UNIX</trademark> scheme of dividing the run of a process in two halves: the kernel and user space. The kernel can be entered in two ways: via a trap or via a syscall. The return is handled only in one way. The further description applies to <trademark class=\"registered\">Linux</trademark> 2.6 on the <trademark>i386</trademark> architecture. This information was taken from [2]."
msgstr ""

#. (itstool) path: sect4/para
#: article.translate.xml:504
msgid "Syscalls in <trademark class=\"registered\">Linux</trademark> are performed (in userspace) using <literal>syscallX</literal> macros where X substitutes a number representing the number of parameters of the given syscall. This macro translates to a code that loads <varname>%eax</varname> register with a number of the syscall and executes interrupt <literal>0x80</literal>. After this syscall return is called, which translates negative return values to positive <literal>errno</literal> values and sets <literal>res</literal> to <literal>-1</literal> in case of an error. Whenever the interrupt <literal>0x80</literal> is called the process enters the kernel in system call trap handler. This routine saves all registers on the stack and calls the selected syscall entry. Note that the <trademark class=\"registered\">Linux</trademark> calling convention expects parameters to the syscall to be passed via registers as shown here:"
msgstr ""

#. (itstool) path: listitem/para
#: article.translate.xml:523
msgid "parameter -&gt; <varname>%ebx</varname>"
msgstr ""

#. (itstool) path: listitem/para
#: article.translate.xml:526
msgid "parameter -&gt; <varname>%ecx</varname>"
msgstr ""

#. (itstool) path: listitem/para
#: article.translate.xml:529
msgid "parameter -&gt; <varname>%edx</varname>"
msgstr ""

#. (itstool) path: listitem/para
#: article.translate.xml:532
msgid "parameter -&gt; <varname>%esi</varname>"
msgstr ""

#. (itstool) path: listitem/para
#: article.translate.xml:535
msgid "parameter -&gt; <varname>%edi</varname>"
msgstr ""

#. (itstool) path: listitem/para
#: article.translate.xml:538
msgid "parameter -&gt; <varname>%ebp</varname>"
msgstr ""

#. (itstool) path: sect4/para
#: article.translate.xml:542
msgid "There are some exceptions to this, where <trademark class=\"registered\">Linux</trademark> uses different calling convention (most notably the <literal>clone</literal> syscall)."
msgstr ""

#. (itstool) path: sect4/para
#: article.translate.xml:550
msgid "The trap handlers are introduced in <filename>arch/i386/kernel/traps.c</filename> and most of these handlers live in <filename>arch/i386/kernel/entry.S</filename>, where handling of the traps happens."
msgstr ""

#. (itstool) path: sect4/para
#: article.translate.xml:560
msgid "Return from the syscall is managed by syscall <citerefentry><refentrytitle>exit</refentrytitle><manvolnum>3</manvolnum></citerefentry>, which checks for the process having unfinished work, then checks whether we used user-supplied selectors. If this happens stack fixing is applied and finally the registers are restored from the stack and the process returns to the userspace."
msgstr ""

#. (itstool) path: sect4/para
#: article.translate.xml:571
msgid "In the 2.6 version, the <trademark class=\"registered\">Linux</trademark> operating system redefined some of the traditional <trademark class=\"registered\">UNIX</trademark> primitives, notably PID, TID and thread. PID is defined not to be unique for every process, so for some processes (threads) <citerefentry><refentrytitle>getppid</refentrytitle><manvolnum>2</manvolnum></citerefentry> returns the same value. Unique identification of process is provided by TID. This is because <firstterm>NPTL</firstterm> (New <trademark class=\"registered\">POSIX</trademark> Thread Library) defines threads to be normal processes (so called 1:1 threading). Spawning a new process in <trademark class=\"registered\">Linux</trademark> 2.6 happens using the <literal>clone</literal> syscall (fork variants are reimplemented using it). This clone syscall defines a set of flags that affect behavior of the cloning process regarding thread implementation. The semantic is a bit fuzzy as there is no single flag telling the syscall to create a thread."
msgstr ""

#. (itstool) path: sect4/para
#: article.translate.xml:588
msgid "Implemented clone flags are:"
msgstr ""

#. (itstool) path: listitem/para
#: article.translate.xml:592
msgid "<literal>CLONE_VM</literal> - processes share their memory space"
msgstr ""

#. (itstool) path: listitem/para
#: article.translate.xml:596
msgid "<literal>CLONE_FS</literal> - share umask, cwd and namespace"
msgstr ""

#. (itstool) path: listitem/para
#: article.translate.xml:600
msgid "<literal>CLONE_FILES</literal> - share open files"
msgstr ""

#. (itstool) path: listitem/para
#: article.translate.xml:604
msgid "<literal>CLONE_SIGHAND</literal> - share signal handlers and blocked signals"
msgstr ""

#. (itstool) path: listitem/para
#: article.translate.xml:608
msgid "<literal>CLONE_PARENT</literal> - share parent"
msgstr ""

#. (itstool) path: listitem/para
#: article.translate.xml:612
msgid "<literal>CLONE_THREAD</literal> - be thread (further explanation below)"
msgstr ""

#. (itstool) path: listitem/para
#: article.translate.xml:616
msgid "<literal>CLONE_NEWNS</literal> - new namespace"
msgstr ""

#. (itstool) path: listitem/para
#: article.translate.xml:620
msgid "<literal>CLONE_SYSVSEM</literal> - share SysV undo structures"
msgstr ""

#. (itstool) path: listitem/para
#: article.translate.xml:624
msgid "<literal>CLONE_SETTLS</literal> - setup TLS at supplied address"
msgstr ""

#. (itstool) path: listitem/para
#: article.translate.xml:628
msgid "<literal>CLONE_PARENT_SETTID</literal> - set TID in the parent"
msgstr ""

#. (itstool) path: listitem/para
#: article.translate.xml:632
msgid "<literal>CLONE_CHILD_CLEARTID</literal> - clear TID in the child"
msgstr ""

#. (itstool) path: listitem/para
#: article.translate.xml:636
msgid "<literal>CLONE_CHILD_SETTID</literal> - set TID in the child"
msgstr ""

#. (itstool) path: sect4/para
#: article.translate.xml:641
msgid "<literal>CLONE_PARENT</literal> sets the real parent to the parent of the caller. This is useful for threads because if thread A creates thread B we want thread B to be parented to the parent of the whole thread group. <literal>CLONE_THREAD</literal> does exactly the same thing as <literal>CLONE_PARENT</literal>, <literal>CLONE_VM</literal> and <literal>CLONE_SIGHAND</literal>, rewrites PID to be the same as PID of the caller, sets exit signal to be none and enters the thread group. <literal>CLONE_SETTLS</literal> sets up GDT entries for TLS handling. The <literal>CLONE_*_*TID</literal> set of flags sets/clears user supplied address to TID or 0."
msgstr ""

#. (itstool) path: sect4/para
#: article.translate.xml:655
msgid "As you can see the <literal>CLONE_THREAD</literal> does most of the work and does not seem to fit the scheme very well. The original intention is unclear (even for authors, according to comments in the code) but I think originally there was one threading flag, which was then parcelled among many other flags but this separation was never fully finished. It is also unclear what this partition is good for as glibc does not use that so only hand-written use of the clone permits a programmer to access this features."
msgstr ""

#. (itstool) path: sect4/para
#: article.translate.xml:666
msgid "For non-threaded programs the PID and TID are the same. For threaded programs the first thread PID and TID are the same and every created thread shares the same PID and gets assigned a unique TID (because <literal>CLONE_THREAD</literal> is passed in) also parent is shared for all processes forming this threaded program."
msgstr ""

#. (itstool) path: sect4/para
#: article.translate.xml:674
msgid "The code that implements <citerefentry><refentrytitle>pthread_create</refentrytitle><manvolnum>3</manvolnum></citerefentry> in NPTL defines the clone flags like this:"
msgstr ""

#. (itstool) path: sect4/programlisting
#: article.translate.xml:677
#, no-wrap
msgid ""
"int clone_flags = (CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGNAL\n"
"\n"
" | CLONE_SETTLS | CLONE_PARENT_SETTID\n"
"\n"
"| CLONE_CHILD_CLEARTID | CLONE_SYSVSEM\n"
"#if __ASSUME_NO_CLONE_DETACHED == 0\n"
"\n"
"| CLONE_DETACHED\n"
"#endif\n"
"\n"
"| 0);"
msgstr ""

#. (itstool) path: sect4/para
#: article.translate.xml:689
msgid "The <literal>CLONE_SIGNAL</literal> is defined like"
msgstr ""

#. (itstool) path: sect4/programlisting
#: article.translate.xml:692
#, no-wrap
msgid ""
"#define CLONE_SIGNAL (CLONE_SIGHAND | CLONE_THREAD)"
msgstr ""

#. (itstool) path: sect4/para
#: article.translate.xml:694
msgid "the last 0 means no signal is sent when any of the threads exits."
msgstr ""

#. (itstool) path: sect2/title
#: article.translate.xml:701
msgid "What is emulation"
msgstr ""

#. (itstool) path: sect2/para
#: article.translate.xml:703
msgid "According to a dictionary definition, emulation is the ability of a program or device to imitate another program or device. This is achieved by providing the same reaction to a given stimulus as the emulated object. In practice, the software world mostly sees three types of emulation - a program used to emulate a machine (QEMU, various game console emulators etc.), software emulation of a hardware facility (OpenGL emulators, floating point units emulation etc.) and operating system emulation (either in kernel of the operating system or as a userspace program)."
msgstr ""

#. (itstool) path: sect2/para
#: article.translate.xml:714
msgid "Emulation is usually used in a place, where using the original component is not feasible nor possible at all. For example someone might want to use a program developed for a different operating system than they use. Then emulation comes in handy. Sometimes there is no other way but to use emulation - e.g. when the hardware device you try to use does not exist (yet/anymore) then there is no other way but emulation. This happens often when porting an operating system to a new (non-existent) platform. Sometimes it is just cheaper to emulate."
msgstr ""

#. (itstool) path: sect2/para
#: article.translate.xml:725
msgid "Looking from an implementation point of view, there are two main approaches to the implementation of emulation. You can either emulate the whole thing - accepting possible inputs of the original object, maintaining inner state and emitting correct output based on the state and/or input. This kind of emulation does not require any special conditions and basically can be implemented anywhere for any device/program. The drawback is that implementing such emulation is quite difficult, time-consuming and error-prone. In some cases we can use a simpler approach. Imagine you want to emulate a printer that prints from left to right on a printer that prints from right to left. It is obvious that there is no need for a complex emulation layer but simply reversing of the printed text is sufficient. Sometimes the emulating environment is very similar to the emulated one so just a thin layer of some translation is necessary to provide fully working emulation! As you can see this is much less demanding to implement, so less time-consuming and error-prone than the previous approach. But the necessary condition is that the two environments must be similar enough. The third approach combines the two previous. Most of the time the objects do not provide the same capabilities so in a case of emulating the more powerful one on the less powerful we have to emulate the missing features with full emulation described above."
msgstr ""

#. (itstool) path: sect2/para
#: article.translate.xml:751
msgid "This master thesis deals with emulation of <trademark class=\"registered\">UNIX</trademark> on <trademark class=\"registered\">UNIX</trademark>, which is exactly the case, where only a thin layer of translation is sufficient to provide full emulation. The <trademark class=\"registered\">UNIX</trademark> API consists of a set of syscalls, which are usually self contained and do not affect some global kernel state."
msgstr ""

#. (itstool) path: sect2/para
#: article.translate.xml:758
msgid "There are a few syscalls that affect inner state but this can be dealt with by providing some structures that maintain the extra state."
msgstr ""

#. (itstool) path: sect2/para
#: article.translate.xml:762
msgid "No emulation is perfect and emulations tend to lack some parts but this usually does not cause any serious drawbacks. Imagine a game console emulator that emulates everything but music output. No doubt that the games are playable and one can use the emulator. It might not be that comfortable as the original game console but its an acceptable compromise between price and comfort."
msgstr ""

#. (itstool) path: sect2/para
#: article.translate.xml:770
msgid "The same goes with the <trademark class=\"registered\">UNIX</trademark> API. Most programs can live with a very limited set of syscalls working. Those syscalls tend to be the oldest ones (<citerefentry><refentrytitle>read</refentrytitle><manvolnum>2</manvolnum></citerefentry>/<citerefentry><refentrytitle>write</refentrytitle><manvolnum>2</manvolnum></citerefentry>, <citerefentry><refentrytitle>fork</refentrytitle><manvolnum>2</manvolnum></citerefentry> family, <citerefentry><refentrytitle>signal</refentrytitle><manvolnum>3</manvolnum></citerefentry> handling, <citerefentry><refentrytitle>exit</refentrytitle><manvolnum>3</manvolnum></citerefentry>, <citerefentry><refentrytitle>socket</refentrytitle><manvolnum>2</manvolnum></citerefentry> API) hence it is easy to emulate because their semantics is shared among all <trademark class=\"registered\">UNIX</trademark>es, which exist todays."
msgstr ""

#. (itstool) path: sect1/title
#: article.translate.xml:781
msgid "Emulation"
msgstr ""

#. (itstool) path: sect2/title
#: article.translate.xml:784
msgid "How emulation works in FreeBSD"
msgstr ""

#. (itstool) path: sect2/para
#: article.translate.xml:786
msgid "As stated earlier, FreeBSD supports running binaries from several other <trademark class=\"registered\">UNIX</trademark>es. This works because FreeBSD has an abstraction called the execution class loader. This wedges into the <citerefentry><refentrytitle>execve</refentrytitle><manvolnum>2</manvolnum></citerefentry> syscall, so when <citerefentry><refentrytitle>execve</refentrytitle><manvolnum>2</manvolnum></citerefentry> is about to execute a binary it examines its type."
msgstr ""

#. (itstool) path: sect2/para
#: article.translate.xml:792
msgid "There are basically two types of binaries in FreeBSD. Shell-like text scripts which are identified by <literal>#!</literal> as their first two characters and normal (typically <firstterm>ELF</firstterm>) binaries, which are a representation of a compiled executable object. The vast majority (one could say all of them) of binaries in FreeBSD are from type ELF. ELF files contain a header, which specifies the OS ABI for this ELF file. By reading this information, the operating system can accurately determine what type of binary the given file is."
msgstr ""

#. (itstool) path: sect2/para
#: article.translate.xml:803
msgid "Every OS ABI must be registered in the FreeBSD kernel. This applies to the FreeBSD native OS ABI, as well. So when <citerefentry><refentrytitle>execve</refentrytitle><manvolnum>2</manvolnum></citerefentry> executes a binary it iterates through the list of registered APIs and when it finds the right one it starts to use the information contained in the OS ABI description (its syscall table, <literal>errno</literal> translation table, etc.). So every time the process calls a syscall, it uses its own set of syscalls instead of some global one. This effectively provides a very elegant and easy way of supporting execution of various binary formats."
msgstr ""

#. (itstool) path: sect2/para
#: article.translate.xml:814
msgid "The nature of emulation of different OSes (and also some other subsystems) led developers to invite a handler event mechanism. There are various places in the kernel, where a list of event handlers are called. Every subsystem can register an event handler and they are called accordingly. For example, when a process exits there is a handler called that possibly cleans up whatever the subsystem needs to be cleaned."
msgstr ""

#. (itstool) path: sect2/para
#: article.translate.xml:823
msgid "Those simple facilities provide basically everything that is needed for the emulation infrastructure and in fact these are basically the only things necessary to implement the <trademark class=\"registered\">Linux</trademark> emulation layer."
msgstr ""

#. (itstool) path: sect2/title
#: article.translate.xml:830
msgid "Common primitives in the FreeBSD kernel"
msgstr ""

#. (itstool) path: sect2/para
#: article.translate.xml:832
msgid "Emulation layers need some support from the operating system. I am going to describe some of the supported primitives in the FreeBSD operating system."
msgstr ""

#. (itstool) path: sect3/title
#: article.translate.xml:837
msgid "Locking primitives"
msgstr ""

#. (itstool) path: sect3/para
#: article.translate.xml:839
msgid "Contributed by: Attilio Rao <email>attilio@FreeBSD.org</email>"
msgstr ""

#. (itstool) path: sect3/para
#: article.translate.xml:841
msgid "The FreeBSD synchronization primitive set is based on the idea to supply a rather huge number of different primitives in a way that the better one can be used for every particular, appropriate situation."
msgstr ""

#. (itstool) path: sect3/para
#: article.translate.xml:846
msgid "To a high level point of view you can consider three kinds of synchronization primitives in the FreeBSD kernel:"
msgstr ""

#. (itstool) path: listitem/para
#: article.translate.xml:852
msgid "atomic operations and memory barriers"
msgstr ""

#. (itstool) path: listitem/para
#: article.translate.xml:855
msgid "locks"
msgstr ""

#. (itstool) path: listitem/para
#: article.translate.xml:858
msgid "scheduling barriers"
msgstr ""

#. (itstool) path: sect3/para
#: article.translate.xml:862
msgid "Below there are descriptions for the 3 families. For every lock, you should really check the linked manpage (where possible) for more detailed explanations."
msgstr ""

#. (itstool) path: sect4/title
#: article.translate.xml:867
msgid "Atomic operations and memory barriers"
msgstr ""

#. (itstool) path: sect4/para
#: article.translate.xml:869
msgid "Atomic operations are implemented through a set of functions performing simple arithmetics on memory operands in an atomic way with respect to external events (interrupts, preemption, etc.). Atomic operations can guarantee atomicity just on small data types (in the magnitude order of the <literal>.long.</literal> architecture C data type), so should be rarely used directly in the end-level code, if not only for very simple operations (like flag setting in a bitmap, for example). In fact, it is rather simple and common to write down a wrong semantic based on just atomic operations (usually referred as lock-less). The FreeBSD kernel offers a way to perform atomic operations in conjunction with a memory barrier. The memory barriers will guarantee that an atomic operation will happen following some specified ordering with respect to other memory accesses. For example, if we need that an atomic operation happen just after all other pending writes (in terms of instructions reordering buffers activities) are completed, we need to explicitly use a memory barrier in conjunction to this atomic operation. So it is simple to understand why memory barriers play a key role for higher-level locks building (just as refcounts, mutexes, etc.). For a detailed explanatory on atomic operations, please refer to <citerefentry><refentrytitle>atomic</refentrytitle><manvolnum>9</manvolnum></citerefentry>. It is far, however, noting that atomic operations (and memory barriers as well) should ideally only be used for building front-ending locks (as mutexes)."
msgstr ""

#. (itstool) path: sect4/title
#: article.translate.xml:900
msgid "Refcounts"
msgstr ""

#. (itstool) path: sect4/para
#: article.translate.xml:902
msgid "Refcounts are interfaces for handling reference counters. They are implemented through atomic operations and are intended to be used just for cases, where the reference counter is the only one thing to be protected, so even something like a spin-mutex is deprecated. Using the refcount interface for structures, where a mutex is already used is often wrong since we should probably close the reference counter in some already protected paths. A manpage discussing refcount does not exist currently, just check <filename>sys/refcount.h</filename> for an overview of the existing API."
msgstr ""

#. (itstool) path: sect4/title
#: article.translate.xml:916
msgid "Locks"
msgstr ""

#. (itstool) path: sect4/para
#: article.translate.xml:918
msgid "FreeBSD kernel has huge classes of locks. Every lock is defined by some peculiar properties, but probably the most important is the event linked to contesting holders (or in other terms, the behavior of threads unable to acquire the lock). FreeBSD's locking scheme presents three different behaviors for contenders:"
msgstr ""

#. (itstool) path: listitem/para
#: article.translate.xml:927
msgid "spinning"
msgstr ""

#. (itstool) path: listitem/para
#: article.translate.xml:930
msgid "blocking"
msgstr ""

#. (itstool) path: listitem/para
#: article.translate.xml:933
msgid "sleeping"
msgstr ""

#. (itstool) path: note/para
#: article.translate.xml:938
msgid "numbers are not casual"
msgstr ""

#. (itstool) path: sect4/title
#: article.translate.xml:943
msgid "Spinning locks"
msgstr ""

#. (itstool) path: sect4/para
#: article.translate.xml:945
msgid "Spin locks let waiters to spin until they cannot acquire the lock. An important matter do deal with is when a thread contests on a spin lock if it is not descheduled. Since the FreeBSD kernel is preemptive, this exposes spin lock at the risk of deadlocks that can be solved just disabling interrupts while they are acquired. For this and other reasons (like lack of priority propagation support, poorness in load balancing schemes between CPUs, etc.), spin locks are intended to protect very small paths of code, or ideally not to be used at all if not explicitly requested (explained later)."
msgstr ""

#. (itstool) path: sect4/title
#: article.translate.xml:959
msgid "Blocking"
msgstr ""

#. (itstool) path: sect4/para
#: article.translate.xml:961
msgid "Block locks let waiters to be descheduled and blocked until the lock owner does not drop it and wakes up one or more contenders. In order to avoid starvation issues, blocking locks do priority propagation from the waiters to the owner. Block locks must be implemented through the turnstile interface and are intended to be the most used kind of locks in the kernel, if no particular conditions are met."
msgstr ""

#. (itstool) path: sect4/title
#: article.translate.xml:972
msgid "Sleeping"
msgstr ""

#. (itstool) path: sect4/para
#: article.translate.xml:974
msgid "Sleep locks let waiters to be descheduled and fall asleep until the lock holder does not drop it and wakes up one or more waiters. Since sleep locks are intended to protect large paths of code and to cater asynchronous events, they do not do any form of priority propagation. They must be implemented through the <citerefentry><refentrytitle>sleepqueue</refentrytitle><manvolnum>9</manvolnum></citerefentry> interface."
msgstr ""

#. (itstool) path: sect4/para
#: article.translate.xml:982
msgid "The order used to acquire locks is very important, not only for the possibility to deadlock due at lock order reversals, but even because lock acquisition should follow specific rules linked to locks natures. If you give a look at the table above, the practical rule is that if a thread holds a lock of level n (where the level is the number listed close to the kind of lock) it is not allowed to acquire a lock of superior levels, since this would break the specified semantic for a path. For example, if a thread holds a block lock (level 2), it is allowed to acquire a spin lock (level 1) but not a sleep lock (level 3), since block locks are intended to protect smaller paths than sleep lock (these rules are not about atomic operations or scheduling barriers, however)."
msgstr ""

#. (itstool) path: sect4/para
#: article.translate.xml:997
msgid "This is a list of lock with their respective behaviors:"
msgstr ""

#. (itstool) path: listitem/para
#: article.translate.xml:1002
msgid "spin mutex - spinning - <citerefentry><refentrytitle>mutex</refentrytitle><manvolnum>9</manvolnum></citerefentry>"
msgstr ""

#. (itstool) path: listitem/para
#: article.translate.xml:1005
msgid "sleep mutex - blocking - <citerefentry><refentrytitle>mutex</refentrytitle><manvolnum>9</manvolnum></citerefentry>"
msgstr ""

#. (itstool) path: listitem/para
#: article.translate.xml:1008
msgid "pool mutex - blocking - <citerefentry><refentrytitle>mtx_pool</refentrytitle><manvolnum>9</manvolnum></citerefentry>"
msgstr ""

#. (itstool) path: listitem/para
#: article.translate.xml:1011
msgid "sleep family - sleeping - <citerefentry><refentrytitle>sleep</refentrytitle><manvolnum>9</manvolnum></citerefentry> pause tsleep msleep msleep spin msleep rw msleep sx"
msgstr ""

#. (itstool) path: listitem/para
#: article.translate.xml:1015
msgid "condvar - sleeping - <citerefentry><refentrytitle>condvar</refentrytitle><manvolnum>9</manvolnum></citerefentry>"
msgstr ""

#. (itstool) path: listitem/para
#: article.translate.xml:1018
msgid "rwlock - blocking - <citerefentry><refentrytitle>rwlock</refentrytitle><manvolnum>9</manvolnum></citerefentry>"
msgstr ""

#. (itstool) path: listitem/para
#: article.translate.xml:1021
msgid "sxlock - sleeping - <citerefentry><refentrytitle>sx</refentrytitle><manvolnum>9</manvolnum></citerefentry>"
msgstr ""

#. (itstool) path: listitem/para
#: article.translate.xml:1024
msgid "lockmgr - sleeping - <citerefentry><refentrytitle>lockmgr</refentrytitle><manvolnum>9</manvolnum></citerefentry>"
msgstr ""

#. (itstool) path: listitem/para
#: article.translate.xml:1027
msgid "semaphores - sleeping - <citerefentry><refentrytitle>sema</refentrytitle><manvolnum>9</manvolnum></citerefentry>"
msgstr ""

#. (itstool) path: sect4/para
#: article.translate.xml:1031
msgid "Among these locks only mutexes, sxlocks, rwlocks and lockmgrs are intended to handle recursion, but currently recursion is only supported by mutexes and lockmgrs."
msgstr ""

#. (itstool) path: sect4/title
#: article.translate.xml:1038
msgid "Scheduling barriers"
msgstr ""

#. (itstool) path: sect4/para
#: article.translate.xml:1040
msgid "Scheduling barriers are intended to be used in order to drive scheduling of threading. They consist mainly of three different stubs:"
msgstr ""

#. (itstool) path: listitem/para
#: article.translate.xml:1046
msgid "critical sections (and preemption)"
msgstr ""

#. (itstool) path: listitem/para
#: article.translate.xml:1049
msgid "sched_bind"
msgstr ""

#. (itstool) path: listitem/para
#: article.translate.xml:1052
msgid "sched_pin"
msgstr ""

#. (itstool) path: sect4/para
#: article.translate.xml:1056
msgid "Generally, these should be used only in a particular context and even if they can often replace locks, they should be avoided because they do not let the diagnose of simple eventual problems with locking debugging tools (as <citerefentry><refentrytitle>witness</refentrytitle><manvolnum>4</manvolnum></citerefentry>)."
msgstr ""

#. (itstool) path: sect4/title
#: article.translate.xml:1064
msgid "Critical sections"
msgstr ""

#. (itstool) path: sect4/para
#: article.translate.xml:1066
msgid "The FreeBSD kernel has been made preemptive basically to deal with interrupt threads. In fact, in order to avoid high interrupt latency, time-sharing priority threads can be preempted by interrupt threads (in this way, they do not need to wait to be scheduled as the normal path previews). Preemption, however, introduces new racing points that need to be handled, as well. Often, in order to deal with preemption, the simplest thing to do is to completely disable it. A critical section defines a piece of code (borderlined by the pair of functions <citerefentry><refentrytitle>critical_enter</refentrytitle><manvolnum>9</manvolnum></citerefentry> and <citerefentry><refentrytitle>critical_exit</refentrytitle><manvolnum>9</manvolnum></citerefentry>, where preemption is guaranteed to not happen (until the protected code is fully executed). This can often replace a lock effectively but should be used carefully in order to not lose the whole advantage that preemption brings."
msgstr ""

#. (itstool) path: sect4/title
#: article.translate.xml:1085
msgid "sched_pin/sched_unpin"
msgstr ""

#. (itstool) path: sect4/para
#: article.translate.xml:1087
msgid "Another way to deal with preemption is the <function>sched_pin()</function> interface. If a piece of code is closed in the <function>sched_pin()</function> and <function>sched_unpin()</function> pair of functions it is guaranteed that the respective thread, even if it can be preempted, it will always be executed on the same CPU. Pinning is very effective in the particular case when we have to access at per-cpu datas and we assume other threads will not change those data. The latter condition will determine a critical section as a too strong condition for our code."
msgstr ""

#. (itstool) path: sect4/title
#: article.translate.xml:1101
msgid "sched_bind/sched_unbind"
msgstr ""

#. (itstool) path: sect4/para
#: article.translate.xml:1103
msgid "<function>sched_bind</function> is an API used in order to bind a thread to a particular CPU for all the time it executes the code, until a <function>sched_unbind</function> function call does not unbind it. This feature has a key role in situations where you cannot trust the current state of CPUs (for example, at very early stages of boot), as you want to avoid your thread to migrate on inactive CPUs. Since <function>sched_bind</function> and <function>sched_unbind</function> manipulate internal scheduler structures, they need to be enclosed in <function>sched_lock</function> acquisition/releasing when used."
msgstr ""

#. (itstool) path: sect3/title
#: article.translate.xml:1120
msgid "Proc structure"
msgstr ""

#. (itstool) path: sect3/para
#: article.translate.xml:1122
msgid "Various emulation layers sometimes require some additional per-process data. It can manage separate structures (a list, a tree etc.) containing these data for every process but this tends to be slow and memory consuming. To solve this problem the FreeBSD <literal>proc</literal> structure contains <literal>p_emuldata</literal>, which is a void pointer to some emulation layer specific data. This <literal>proc</literal> entry is protected by the proc mutex."
msgstr ""

#. (itstool) path: sect3/para
#: article.translate.xml:1133
msgid "The FreeBSD <literal>proc</literal> structure contains a <literal>p_sysent</literal> entry that identifies, which ABI this process is running. In fact, it is a pointer to the <literal>sysentvec</literal> described above. So by comparing this pointer to the address where the <literal>sysentvec</literal> structure for the given ABI is stored we can effectively determine whether the process belongs to our emulation layer. The code typically looks like:"
msgstr ""

#. (itstool) path: sect3/programlisting
#: article.translate.xml:1143
#, no-wrap
msgid ""
"if (__predict_true(p-&gt;p_sysent != &amp;elf_<trademark class=\"registered\">Linux</trademark>_sysvec))\n"
"\t  return;"
msgstr ""

#. (itstool) path: sect3/para
#: article.translate.xml:1146
msgid "As you can see, we effectively use the <literal>__predict_true</literal> modifier to collapse the most common case (FreeBSD process) to a simple return operation thus preserving high performance. This code should be turned into a macro because currently it is not very flexible, i.e. we do not support <trademark class=\"registered\">Linux</trademark>64 emulation nor A.OUT <trademark class=\"registered\">Linux</trademark> processes on i386."
msgstr ""

#. (itstool) path: sect3/title
#: article.translate.xml:1156
msgid "VFS"
msgstr ""

#. (itstool) path: sect3/para
#: article.translate.xml:1158
msgid "The FreeBSD VFS subsystem is very complex but the <trademark class=\"registered\">Linux</trademark> emulation layer uses just a small subset via a well defined API. It can either operate on vnodes or file handlers. Vnode represents a virtual vnode, i.e. representation of a node in VFS. Another representation is a file handler, which represents an opened file from the perspective of a process. A file handler can represent a socket or an ordinary file. A file handler contains a pointer to its vnode. More then one file handler can point to the same vnode."
msgstr ""

#. (itstool) path: sect4/title
#: article.translate.xml:1170
msgid "namei"
msgstr ""

#. (itstool) path: sect4/para
#: article.translate.xml:1172
msgid "The <citerefentry><refentrytitle>namei</refentrytitle><manvolnum>9</manvolnum></citerefentry> routine is a central entry point to pathname lookup and translation. It traverses the path point by point from the starting point to the end point using lookup function, which is internal to VFS. The <citerefentry><refentrytitle>namei</refentrytitle><manvolnum>9</manvolnum></citerefentry> syscall can cope with symlinks, absolute and relative paths. When a path is looked up using <citerefentry><refentrytitle>namei</refentrytitle><manvolnum>9</manvolnum></citerefentry> it is inputed to the name cache. This behavior can be suppressed. This routine is used all over the kernel and its performance is very critical."
msgstr ""

#. (itstool) path: sect4/title
#: article.translate.xml:1184
msgid "vn_fullpath"
msgstr ""

#. (itstool) path: sect4/para
#: article.translate.xml:1186
msgid "The <citerefentry><refentrytitle>vn_fullpath</refentrytitle><manvolnum>9</manvolnum></citerefentry> function takes the best effort to traverse VFS name cache and returns a path for a given (locked) vnode. This process is unreliable but works just fine for the most common cases. The unreliability is because it relies on VFS cache (it does not traverse the on medium structures), it does not work with hardlinks, etc. This routine is used in several places in the Linuxulator."
msgstr ""

#. (itstool) path: sect4/title
#: article.translate.xml:1197
msgid "Vnode operations"
msgstr ""

#. (itstool) path: listitem/para
#: article.translate.xml:1201
msgid "<function>fgetvp</function> - given a thread and a file descriptor number it returns the associated vnode"
msgstr ""

#. (itstool) path: listitem/para
#: article.translate.xml:1206
msgid "<citerefentry><refentrytitle>vn_lock</refentrytitle><manvolnum>9</manvolnum></citerefentry> - locks a vnode"
msgstr ""

#. (itstool) path: listitem/para
#: article.translate.xml:1209
msgid "<function>vn_unlock</function> - unlocks a vnode"
msgstr ""

#. (itstool) path: listitem/para
#: article.translate.xml:1213
msgid "<citerefentry><refentrytitle>VOP_READDIR</refentrytitle><manvolnum>9</manvolnum></citerefentry> - reads a directory referenced by a vnode"
msgstr ""

#. (itstool) path: listitem/para
#: article.translate.xml:1217
msgid "<citerefentry><refentrytitle>VOP_GETATTR</refentrytitle><manvolnum>9</manvolnum></citerefentry> - gets attributes of a file or a directory referenced by a vnode"
msgstr ""

#. (itstool) path: listitem/para
#: article.translate.xml:1221
msgid "<citerefentry><refentrytitle>VOP_LOOKUP</refentrytitle><manvolnum>9</manvolnum></citerefentry> - looks up a path to a given directory"
msgstr ""

#. (itstool) path: listitem/para
#: article.translate.xml:1225
msgid "<citerefentry><refentrytitle>VOP_OPEN</refentrytitle><manvolnum>9</manvolnum></citerefentry> - opens a file referenced by a vnode"
msgstr ""

#. (itstool) path: listitem/para
#: article.translate.xml:1229
msgid "<citerefentry><refentrytitle>VOP_CLOSE</refentrytitle><manvolnum>9</manvolnum></citerefentry> - closes a file referenced by a vnode"
msgstr ""

#. (itstool) path: listitem/para
#: article.translate.xml:1233
msgid "<citerefentry><refentrytitle>vput</refentrytitle><manvolnum>9</manvolnum></citerefentry> - decrements the use count for a vnode and unlocks it"
msgstr ""

#. (itstool) path: listitem/para
#: article.translate.xml:1237
msgid "<citerefentry><refentrytitle>vrele</refentrytitle><manvolnum>9</manvolnum></citerefentry> - decrements the use count for a vnode"
msgstr ""

#. (itstool) path: listitem/para
#: article.translate.xml:1241
msgid "<citerefentry><refentrytitle>vref</refentrytitle><manvolnum>9</manvolnum></citerefentry> - increments the use count for a vnode"
msgstr ""

#. (itstool) path: sect4/title
#: article.translate.xml:1248
msgid "File handler operations"
msgstr ""

#. (itstool) path: listitem/para
#: article.translate.xml:1252
msgid "<function>fget</function> - given a thread and a file descriptor number it returns associated file handler and references it"
msgstr ""

#. (itstool) path: listitem/para
#: article.translate.xml:1257
msgid "<function>fdrop</function> - drops a reference to a file handler"
msgstr ""

#. (itstool) path: listitem/para
#: article.translate.xml:1261
msgid "<function>fhold</function> - references a file handler"
msgstr ""

#. (itstool) path: sect1/title
#: article.translate.xml:1271
msgid "<trademark class=\"registered\">Linux</trademark> emulation layer -MD part"
msgstr ""

#. (itstool) path: sect1/para
#: article.translate.xml:1273
msgid "This section deals with implementation of <trademark class=\"registered\">Linux</trademark> emulation layer in FreeBSD operating system. It first describes the machine dependent part talking about how and where interaction between userland and kernel is implemented. It talks about syscalls, signals, ptrace, traps, stack fixup. This part discusses i386 but it is written generally so other architectures should not differ very much. The next part is the machine independent part of the Linuxulator. This section only covers i386 and ELF handling. A.OUT is obsolete and untested."
msgstr ""

#. (itstool) path: sect2/title
#: article.translate.xml:1284
msgid "Syscall handling"
msgstr ""

#. (itstool) path: sect2/para
#: article.translate.xml:1286
msgid "Syscall handling is mostly written in <filename>linux_sysvec.c</filename>, which covers most of the routines pointed out in the <literal>sysentvec</literal> structure. When a <trademark class=\"registered\">Linux</trademark> process running on FreeBSD issues a syscall, the general syscall routine calls linux prepsyscall routine for the <trademark class=\"registered\">Linux</trademark> ABI."
msgstr ""

#. (itstool) path: sect3/title
#: article.translate.xml:1294
msgid "<trademark class=\"registered\">Linux</trademark> prepsyscall"
msgstr ""

#. (itstool) path: sect3/para
#: article.translate.xml:1296
msgid "<trademark class=\"registered\">Linux</trademark> passes arguments to syscalls via registers (that is why it is limited to 6 parameters on i386) while FreeBSD uses the stack. The <trademark class=\"registered\">Linux</trademark> prepsyscall routine must copy parameters from registers to the stack. The order of the registers is: <varname>%ebx</varname>, <varname>%ecx</varname>, <varname>%edx</varname>, <varname>%esi</varname>, <varname>%edi</varname>, <varname>%ebp</varname>. The catch is that this is true for only <emphasis>most</emphasis> of the syscalls. Some (most notably <function>clone</function>) uses a different order but it is luckily easy to fix by inserting a dummy parameter in the <function>linux_clone</function> prototype."
msgstr ""

#. (itstool) path: sect3/title
#: article.translate.xml:1311
msgid "Syscall writing"
msgstr ""

#. (itstool) path: sect3/para
#: article.translate.xml:1313
msgid "Every syscall implemented in the Linuxulator must have its prototype with various flags in <filename>syscalls.master</filename>. The form of the file is:"
msgstr ""

#. (itstool) path: sect3/programlisting
#: article.translate.xml:1318
#, no-wrap
msgid ""
"...\n"
"\tAUE_FORK STD\t\t{ int linux_fork(void); }\n"
"...\n"
"\tAUE_CLOSE NOPROTO\t{ int close(int fd); }\n"
"..."
msgstr ""

#. (itstool) path: sect3/para
#: article.translate.xml:1324
msgid "The first column represents the syscall number. The second column is for auditing support. The third column represents the syscall type. It is either <literal>STD</literal>, <literal>OBSOL</literal>, <literal>NOPROTO</literal> and <literal>UNIMPL</literal>. <literal>STD</literal> is a standard syscall with full prototype and implementation. <literal>OBSOL</literal> is obsolete and defines just the prototype. <literal>NOPROTO</literal> means that the syscall is implemented elsewhere so do not prepend ABI prefix, etc. <literal>UNIMPL</literal> means that the syscall will be substituted with the <function>nosys</function> syscall (a syscall just printing out a message about the syscall not being implemented and returning <literal>ENOSYS</literal>)."
msgstr ""

#. (itstool) path: sect3/para
#: article.translate.xml:1340
msgid "From <filename>syscalls.master</filename> a script generates three files: <filename>linux_syscall.h</filename>, <filename>linux_proto.h</filename> and <filename>linux_sysent.c</filename>. The <filename>linux_syscall.h</filename> contains definitions of syscall names and their numerical value, e.g.:"
msgstr ""

#. (itstool) path: sect3/programlisting
#: article.translate.xml:1347
#, no-wrap
msgid ""
"...\n"
"#define LINUX_SYS_linux_fork 2\n"
"...\n"
"#define LINUX_SYS_close 6\n"
"..."
msgstr ""

#. (itstool) path: sect3/para
#: article.translate.xml:1353
msgid "The <filename>linux_proto.h</filename> contains structure definitions of arguments to every syscall, e.g.:"
msgstr ""

#. (itstool) path: sect3/programlisting
#: article.translate.xml:1357
#, no-wrap
msgid ""
"struct linux_fork_args {\n"
"  register_t dummy;\n"
"};"
msgstr ""

#. (itstool) path: sect3/para
#: article.translate.xml:1361
msgid "And finally, <filename>linux_sysent.c</filename> contains structure describing the system entry table, used to actually dispatch a syscall, e.g.:"
msgstr ""

#. (itstool) path: sect3/programlisting
#: article.translate.xml:1365
#, no-wrap
msgid ""
"{ 0, (sy_call_t *)linux_fork, AUE_FORK, NULL, 0, 0 }, /* 2 = linux_fork */\n"
"{ AS(close_args), (sy_call_t *)close, AUE_CLOSE, NULL, 0, 0 }, /* 6 = close */"
msgstr ""

#. (itstool) path: sect3/para
#: article.translate.xml:1368
msgid "As you can see <function>linux_fork</function> is implemented in Linuxulator itself so the definition is of <literal>STD</literal> type and has no argument, which is exhibited by the dummy argument structure. On the other hand <function>close</function> is just an alias for real FreeBSD <citerefentry><refentrytitle>close</refentrytitle><manvolnum>2</manvolnum></citerefentry> so it has no linux arguments structure associated and in the system entry table it is not prefixed with linux as it calls the real <citerefentry><refentrytitle>close</refentrytitle><manvolnum>2</manvolnum></citerefentry> in the kernel."
msgstr ""

#. (itstool) path: sect3/title
#: article.translate.xml:1380
msgid "Dummy syscalls"
msgstr ""

#. (itstool) path: sect3/para
#: article.translate.xml:1382
msgid "The <trademark class=\"registered\">Linux</trademark> emulation layer is not complete, as some syscalls are not implemented properly and some are not implemented at all. The emulation layer employs a facility to mark unimplemented syscalls with the <literal>DUMMY</literal> macro. These dummy definitions reside in <filename>linux_dummy.c</filename> in a form of <literal>DUMMY(syscall);</literal>, which is then translated to various syscall auxiliary files and the implementation consists of printing a message saying that this syscall is not implemented. The <literal>UNIMPL</literal> prototype is not used because we want to be able to identify the name of the syscall that was called in order to know what syscalls are more important to implement."
msgstr ""

#. (itstool) path: sect2/title
#: article.translate.xml:1399
msgid "Signal handling"
msgstr ""

#. (itstool) path: sect2/para
#: article.translate.xml:1401
msgid "Signal handling is done generally in the FreeBSD kernel for all binary compatibilities with a call to a compat-dependent layer. <trademark class=\"registered\">Linux</trademark> compatibility layer defines <function>linux_sendsig</function> routine for this purpose."
msgstr ""

#. (itstool) path: sect3/title
#: article.translate.xml:1408
msgid "<trademark class=\"registered\">Linux</trademark> sendsig"
msgstr ""

#. (itstool) path: sect3/para
#: article.translate.xml:1410
msgid "This routine first checks whether the signal has been installed with a <literal>SA_SIGINFO</literal> in which case it calls <function>linux_rt_sendsig</function> routine instead. Furthermore, it allocates (or reuses an already existing) signal handle context, then it builds a list of arguments for the signal handler. It translates the signal number based on the signal translation table, assigns a handler, translates sigset. Then it saves context for the <function>sigreturn</function> routine (various registers, translated trap number and signal mask). Finally, it copies out the signal context to the userspace and prepares context for the actual signal handler to run."
msgstr ""

#. (itstool) path: sect3/title
#: article.translate.xml:1425
msgid "linux_rt_sendsig"
msgstr ""

#. (itstool) path: sect3/para
#: article.translate.xml:1427
msgid "This routine is similar to <function>linux_sendsig</function> just the signal context preparation is different. It adds <literal>siginfo</literal>, <literal>ucontext</literal>, and some <trademark class=\"registered\">POSIX</trademark> parts. It might be worth considering whether those two functions could not be merged with a benefit of less code duplication and possibly even faster execution."
msgstr ""

#. (itstool) path: sect3/title
#: article.translate.xml:1438
msgid "linux_sigreturn"
msgstr ""

#. (itstool) path: sect3/para
#: article.translate.xml:1440
msgid "This syscall is used for return from the signal handler. It does some security checks and restores the original process context. It also unmasks the signal in process signal mask."
msgstr ""

#. (itstool) path: sect2/title
#: article.translate.xml:1448
msgid "Ptrace"
msgstr ""

#. (itstool) path: sect2/para
#: article.translate.xml:1450
msgid "Many <trademark class=\"registered\">UNIX</trademark> derivates implement the <citerefentry><refentrytitle>ptrace</refentrytitle><manvolnum>2</manvolnum></citerefentry> syscall in order to allow various tracking and debugging features. This facility enables the tracing process to obtain various information about the traced process, like register dumps, any memory from the process address space, etc. and also to trace the process like in stepping an instruction or between system entries (syscalls and traps). <citerefentry><refentrytitle>ptrace</refentrytitle><manvolnum>2</manvolnum></citerefentry> also lets you set various information in the traced process (registers etc.). <citerefentry><refentrytitle>ptrace</refentrytitle><manvolnum>2</manvolnum></citerefentry> is a <trademark class=\"registered\">UNIX</trademark>-wide standard implemented in most <trademark class=\"registered\">UNIX</trademark>es around the world."
msgstr ""

#. (itstool) path: sect2/para
#: article.translate.xml:1461
msgid "<trademark class=\"registered\">Linux</trademark> emulation in FreeBSD implements the <citerefentry><refentrytitle>ptrace</refentrytitle><manvolnum>2</manvolnum></citerefentry> facility in <filename>linux_ptrace.c</filename>. The routines for converting registers between <trademark class=\"registered\">Linux</trademark> and FreeBSD and the actual <citerefentry><refentrytitle>ptrace</refentrytitle><manvolnum>2</manvolnum></citerefentry> syscall emulation syscall. The syscall is a long switch block that implements its counterpart in FreeBSD for every <citerefentry><refentrytitle>ptrace</refentrytitle><manvolnum>2</manvolnum></citerefentry> command. The <citerefentry><refentrytitle>ptrace</refentrytitle><manvolnum>2</manvolnum></citerefentry> commands are mostly equal between <trademark class=\"registered\">Linux</trademark> and FreeBSD so usually just a small modification is needed. For example, <literal>PT_GETREGS</literal> in <trademark class=\"registered\">Linux</trademark> operates on direct data while FreeBSD uses a pointer to the data so after performing a (native) <citerefentry><refentrytitle>ptrace</refentrytitle><manvolnum>2</manvolnum></citerefentry> syscall, a copyout must be done to preserve <trademark class=\"registered\">Linux</trademark> semantics."
msgstr ""

#. (itstool) path: sect2/para
#: article.translate.xml:1474
msgid "The <citerefentry><refentrytitle>ptrace</refentrytitle><manvolnum>2</manvolnum></citerefentry> implementation in Linuxulator has some known weaknesses. There have been panics seen when using <command>strace</command> (which is a <citerefentry><refentrytitle>ptrace</refentrytitle><manvolnum>2</manvolnum></citerefentry> consumer) in the Linuxulator environment. Also <literal>PT_SYSCALL</literal> is not implemented."
msgstr ""

#. (itstool) path: sect2/para
#: article.translate.xml:1484
msgid "Whenever a <trademark class=\"registered\">Linux</trademark> process running in the emulation layer traps the trap itself is handled transparently with the only exception of the trap translation. <trademark class=\"registered\">Linux</trademark> and FreeBSD differs in opinion on what a trap is so this is dealt with here. The code is actually very short:"
msgstr ""

#. (itstool) path: sect2/programlisting
#: article.translate.xml:1490
#, no-wrap
msgid ""
"static int\n"
"translate_traps(int signal, int trap_code)\n"
"{\n"
"\n"
"  if (signal != SIGBUS)\n"
"    return signal;\n"
"\n"
"  switch (trap_code) {\n"
"\n"
"    case T_PROTFLT:\n"
"    case T_TSSFLT:\n"
"    case T_DOUBLEFLT:\n"
"    case T_PAGEFLT:\n"
"      return SIGSEGV;\n"
"\n"
"    default:\n"
"      return signal;\n"
"  }\n"
"}"
msgstr ""

#. (itstool) path: sect2/title
#: article.translate.xml:1512
msgid "Stack fixup"
msgstr ""

#. (itstool) path: sect2/para
#: article.translate.xml:1514
msgid "The RTLD run-time link-editor expects so called AUX tags on stack during an <function>execve</function> so a fixup must be done to ensure this. Of course, every RTLD system is different so the emulation layer must provide its own stack fixup routine to do this. So does Linuxulator. The <function>elf_linux_fixup</function> simply copies out AUX tags to the stack and adjusts the stack of the user space process to point right after those tags. So RTLD works in a smart way."
msgstr ""

#. (itstool) path: sect2/title
#: article.translate.xml:1526
msgid "A.OUT support"
msgstr ""

#. (itstool) path: sect2/para
#: article.translate.xml:1528
msgid "The <trademark class=\"registered\">Linux</trademark> emulation layer on i386 also supports <trademark class=\"registered\">Linux</trademark> A.OUT binaries. Pretty much everything described in the previous sections must be implemented for A.OUT support (beside traps translation and signals sending). The support for A.OUT binaries is no longer maintained, especially the 2.6 emulation does not work with it but this does not cause any problem, as the linux-base in ports probably do not support A.OUT binaries at all. This support will probably be removed in future. Most of the stuff necessary for loading <trademark class=\"registered\">Linux</trademark> A.OUT binaries is in <filename>imgact_linux.c</filename> file."
msgstr ""

#. (itstool) path: sect1/title
#: article.translate.xml:1543
msgid "<trademark class=\"registered\">Linux</trademark> emulation layer -MI part"
msgstr ""

#. (itstool) path: sect1/para
#: article.translate.xml:1545
msgid "This section talks about machine independent part of the Linuxulator. It covers the emulation infrastructure needed for <trademark class=\"registered\">Linux</trademark> 2.6 emulation, the thread local storage (TLS) implementation (on i386) and futexes. Then we talk briefly about some syscalls."
msgstr ""

#. (itstool) path: sect2/title
#: article.translate.xml:1552
msgid "Description of NPTL"
msgstr ""

#. (itstool) path: sect2/para
#: article.translate.xml:1554
msgid "One of the major areas of progress in development of <trademark class=\"registered\">Linux</trademark> 2.6 was threading. Prior to 2.6, the <trademark class=\"registered\">Linux</trademark> threading support was implemented in the <application>linuxthreads</application> library. The library was a partial implementation of <trademark class=\"registered\">POSIX</trademark> threading. The threading was implemented using separate processes for each thread using the <function>clone</function> syscall to let them share the address space (and other things). The main weaknesses of this approach was that every thread had a different PID, signal handling was broken (from the pthreads perspective), etc. Also the performance was not very good (use of <literal>SIGUSR</literal> signals for threads synchronization, kernel resource consumption, etc.) so to overcome these problems a new threading system was developed and named NPTL."
msgstr ""

#. (itstool) path: sect2/para
#: article.translate.xml:1570
msgid "The NPTL library focused on two things but a third thing came along so it is usually considered a part of NPTL. Those two things were embedding of threads into a process structure and futexes. The additional third thing was TLS, which is not directly required by NPTL but the whole NPTL userland library depends on it. Those improvements yielded in much improved performance and standards conformance. NPTL is a standard threading library in <trademark class=\"registered\">Linux</trademark> systems these days."
msgstr ""

#. (itstool) path: sect2/para
#: article.translate.xml:1579
msgid "The FreeBSD Linuxulator implementation approaches the NPTL in three main areas. The TLS, futexes and PID mangling, which is meant to simulate the <trademark class=\"registered\">Linux</trademark> threads. Further sections describe each of these areas."
msgstr ""

#. (itstool) path: sect2/title
#: article.translate.xml:1586
msgid "<trademark class=\"registered\">Linux</trademark> 2.6 emulation infrastructure"
msgstr ""

#. (itstool) path: sect2/para
#: article.translate.xml:1588
msgid "These sections deal with the way <trademark class=\"registered\">Linux</trademark> threads are managed and how we simulate that in FreeBSD."
msgstr ""

#. (itstool) path: sect3/title
#: article.translate.xml:1592
msgid "Runtime determining of 2.6 emulation"
msgstr ""

#. (itstool) path: sect3/para
#: article.translate.xml:1594
msgid "The <trademark class=\"registered\">Linux</trademark> emulation layer in FreeBSD supports runtime setting of the emulated version. This is done via <citerefentry><refentrytitle>sysctl</refentrytitle><manvolnum>8</manvolnum></citerefentry>, namely <literal>compat.linux.osrelease</literal>. Setting this <citerefentry><refentrytitle>sysctl</refentrytitle><manvolnum>8</manvolnum></citerefentry> affects runtime behavior of the emulation layer. When set to 2.6.x it sets the value of <literal>linux_use_linux26</literal> while setting to something else keeps it unset. This variable (plus per-prison variables of the very same kind) determines whether 2.6 infrastructure (mainly PID mangling) is used in the code or not. The version setting is done system-wide and this affects all <trademark class=\"registered\">Linux</trademark> processes. The <citerefentry><refentrytitle>sysctl</refentrytitle><manvolnum>8</manvolnum></citerefentry> should not be changed when running any <trademark class=\"registered\">Linux</trademark> binary as it might harm things."
msgstr ""

#. (itstool) path: sect3/title
#: article.translate.xml:1611
msgid "<trademark class=\"registered\">Linux</trademark> processes and thread identifiers"
msgstr ""

#. (itstool) path: sect3/para
#: article.translate.xml:1613
msgid "The semantics of <trademark class=\"registered\">Linux</trademark> threading are a little confusing and uses entirely different nomenclature to FreeBSD. A process in <trademark class=\"registered\">Linux</trademark> consists of a <literal>struct task</literal> embedding two identifier fields - PID and TGID. PID is <emphasis>not</emphasis> a process ID but it is a thread ID. The TGID identifies a thread group in other words a process. For single-threaded process the PID equals the TGID."
msgstr ""

#. (itstool) path: sect3/para
#: article.translate.xml:1622
msgid "The thread in NPTL is just an ordinary process that happens to have TGID not equal to PID and have a group leader not equal to itself (and shared VM etc. of course). Everything else happens in the same way as to an ordinary process. There is no separation of a shared status to some external structure like in FreeBSD. This creates some duplication of information and possible data inconsistency. The <trademark class=\"registered\">Linux</trademark> kernel seems to use task -&gt; group information in some places and task information elsewhere and it is really not very consistent and looks error-prone."
msgstr ""

#. (itstool) path: sect3/para
#: article.translate.xml:1633
msgid "Every NPTL thread is created by a call to the <function>clone</function> syscall with a specific set of flags (more in the next subsection). The NPTL implements strict 1:1 threading."
msgstr ""

#. (itstool) path: sect3/para
#: article.translate.xml:1638
msgid "In FreeBSD we emulate NPTL threads with ordinary FreeBSD processes that share VM space, etc. and the PID gymnastic is just mimicked in the emulation specific structure attached to the process. The structure attached to the process looks like:"
msgstr ""

#. (itstool) path: sect3/programlisting
#: article.translate.xml:1644
#, no-wrap
msgid ""
"struct linux_emuldata {\n"
"  pid_t pid;\n"
"\n"
"  int *child_set_tid; /* in clone(): Child.s TID to set on clone */\n"
"  int *child_clear_tid;/* in clone(): Child.s TID to clear on exit */\n"
"\n"
"  struct linux_emuldata_shared *shared;\n"
"\n"
"  int pdeath_signal; /* parent death signal */\n"
"\n"
"  LIST_ENTRY(linux_emuldata) threads; /* list of linux threads */\n"
"};"
msgstr ""

#. (itstool) path: sect3/para
#: article.translate.xml:1657
msgid "The PID is used to identify the FreeBSD process that attaches this structure. The <function>child_se_tid</function> and <function>child_clear_tid</function> are used for TID address copyout when a process exits and is created. The <varname>shared</varname> pointer points to a structure shared among threads. The <varname>pdeath_signal</varname> variable identifies the parent death signal and the <varname>threads</varname> pointer is used to link this structure to the list of threads. The <literal>linux_emuldata_shared</literal> structure looks like:"
msgstr ""

#. (itstool) path: sect3/programlisting
#: article.translate.xml:1670
#, no-wrap
msgid ""
"struct linux_emuldata_shared {\n"
"\n"
"  int refs;\n"
"\n"
"  pid_t group_pid;\n"
"\n"
"  LIST_HEAD(, linux_emuldata) threads; /* head of list of linux threads */\n"
"};"
msgstr ""

#. (itstool) path: sect3/para
#: article.translate.xml:1679
msgid "The <varname>refs</varname> is a reference counter being used to determine when we can free the structure to avoid memory leaks. The <varname>group_pid</varname> is to identify PID ( = TGID) of the whole process ( = thread group). The <varname>threads</varname> pointer is the head of the list of threads in the process."
msgstr ""

#. (itstool) path: sect3/para
#: article.translate.xml:1686
msgid "The <literal>linux_emuldata</literal> structure can be obtained from the process using <function>em_find</function>. The prototype of the function is:"
msgstr ""

#. (itstool) path: sect3/programlisting
#: article.translate.xml:1691
#, no-wrap
msgid ""
"struct linux_emuldata *em_find(struct proc *, int locked);"
msgstr ""

#. (itstool) path: sect3/para
#: article.translate.xml:1693
msgid "Here, <varname>proc</varname> is the process we want the emuldata structure from and the locked parameter determines whether we want to lock or not. The accepted values are <literal>EMUL_DOLOCK</literal> and <literal>EMUL_DOUNLOCK</literal>. More about locking later."
msgstr ""

#. (itstool) path: sect3/title
#: article.translate.xml:1702
msgid "PID mangling"
msgstr ""

#. (itstool) path: sect3/para
#: article.translate.xml:1704
msgid "Because of the described different view knowing what a process ID and thread ID is between FreeBSD and <trademark class=\"registered\">Linux</trademark> we have to translate the view somehow. We do it by PID mangling. This means that we fake what a PID (=TGID) and TID (=PID) is between kernel and userland. The rule of thumb is that in kernel (in Linuxulator) PID = PID and TGID = shared -&gt; group pid and to userland we present <literal>PID = shared -&gt; group_pid</literal> and <literal>TID = proc -&gt; p_pid</literal>. The PID member of <literal>linux_emuldata structure</literal> is a FreeBSD PID."
msgstr ""

#. (itstool) path: sect3/para
#: article.translate.xml:1716
msgid "The above affects mainly getpid, getppid, gettid syscalls. Where we use PID/TGID respectively. In copyout of TIDs in <function>child_clear_tid</function> and <function>child_set_tid</function> we copy out FreeBSD PID."
msgstr ""

#. (itstool) path: sect3/title
#: article.translate.xml:1724
msgid "Clone syscall"
msgstr ""

#. (itstool) path: sect3/para
#: article.translate.xml:1726
msgid "The <function>clone</function> syscall is the way threads are created in <trademark class=\"registered\">Linux</trademark>. The syscall prototype looks like this:"
msgstr ""

#. (itstool) path: sect3/programlisting
#: article.translate.xml:1730
#, no-wrap
msgid ""
"int linux_clone(l_int flags, void *stack, void *parent_tidptr, int dummy,\n"
"void * child_tidptr);"
msgstr ""

#. (itstool) path: sect3/para
#: article.translate.xml:1733
msgid "The <varname>flags</varname> parameter tells the syscall how exactly the processes should be cloned. As described above, <trademark class=\"registered\">Linux</trademark> can create processes sharing various things independently, for example two processes can share file descriptors but not VM, etc. Last byte of the <varname>flags</varname> parameter is the exit signal of the newly created process. The <varname>stack</varname> parameter if non-<literal>NULL</literal> tells, where the thread stack is and if it is <literal>NULL</literal> we are supposed to copy-on-write the calling process stack (i.e. do what normal <citerefentry><refentrytitle>fork</refentrytitle><manvolnum>2</manvolnum></citerefentry> routine does). The <varname>parent_tidptr</varname> parameter is used as an address for copying out process PID (i.e. thread id) once the process is sufficiently instantiated but is not runnable yet. The <varname>dummy</varname> parameter is here because of the very strange calling convention of this syscall on i386. It uses the registers directly and does not let the compiler do it what results in the need of a dummy syscall. The <varname>child_tidptr</varname> parameter is used as an address for copying out PID once the process has finished forking and when the process exits."
msgstr ""

#. (itstool) path: sect3/para
#: article.translate.xml:1755
msgid "The syscall itself proceeds by setting corresponding flags depending on the flags passed in. For example, <literal>CLONE_VM</literal> maps to RFMEM (sharing of VM), etc. The only nit here is <literal>CLONE_FS</literal> and <literal>CLONE_FILES</literal> because FreeBSD does not allow setting this separately so we fake it by not setting RFFDG (copying of fd table and other fs information) if either of these is defined. This does not cause any problems, because those flags are always set together. After setting the flags the process is forked using the internal <function>fork1</function> routine, the process is instrumented not to be put on a run queue, i.e. not to be set runnable. After the forking is done we possibly reparent the newly created process to emulate <literal>CLONE_PARENT</literal> semantics. Next part is creating the emulation data. Threads in <trademark class=\"registered\">Linux</trademark> does not signal their parents so we set exit signal to be 0 to disable this. After that setting of <varname>child_set_tid</varname> and <varname>child_clear_tid</varname> is performed enabling the functionality later in the code. At this point we copy out the PID to the address specified by <varname>parent_tidptr</varname>. The setting of process stack is done by simply rewriting thread frame <varname>%esp</varname> register (<varname>%rsp</varname> on amd64). Next part is setting up TLS for the newly created process. After this <citerefentry><refentrytitle>vfork</refentrytitle><manvolnum>2</manvolnum></citerefentry> semantics might be emulated and finally the newly created process is put on a run queue and copying out its PID to the parent process via <function>clone</function> return value is done."
msgstr ""

#. (itstool) path: sect3/para
#: article.translate.xml:1786
msgid "The <function>clone</function> syscall is able and in fact is used for emulating classic <citerefentry><refentrytitle>fork</refentrytitle><manvolnum>2</manvolnum></citerefentry> and <citerefentry><refentrytitle>vfork</refentrytitle><manvolnum>2</manvolnum></citerefentry> syscalls. Newer glibc in a case of 2.6 kernel uses <function>clone</function> to implement <citerefentry><refentrytitle>fork</refentrytitle><manvolnum>2</manvolnum></citerefentry> and <citerefentry><refentrytitle>vfork</refentrytitle><manvolnum>2</manvolnum></citerefentry> syscalls."
msgstr ""

#. (itstool) path: sect3/title
#: article.translate.xml:1794
msgid "Locking"
msgstr ""

#. (itstool) path: sect3/para
#: article.translate.xml:1796
msgid "The locking is implemented to be per-subsystem because we do not expect a lot of contention on these. There are two locks: <literal>emul_lock</literal> used to protect manipulating of <literal>linux_emuldata</literal> and <literal>emul_shared_lock</literal> used to manipulate <literal>linux_emuldata_shared</literal>. The <literal>emul_lock</literal> is a nonsleepable blocking mutex while <literal>emul_shared_lock</literal> is a sleepable blocking <literal>sx_lock</literal>. Because of the per-subsystem locking we can coalesce some locks and that is why the em find offers the non-locking access."
msgstr ""

#. (itstool) path: sect2/title
#: article.translate.xml:1812
msgid "TLS"
msgstr ""

#. (itstool) path: sect2/para
#: article.translate.xml:1814
msgid "This section deals with TLS also known as thread local storage."
msgstr ""

#. (itstool) path: sect3/title
#: article.translate.xml:1818
msgid "Introduction to threading"
msgstr ""

#. (itstool) path: sect3/para
#: article.translate.xml:1820
msgid "Threads in computer science are entities within a process that can be scheduled independently from each other. The threads in the process share process wide data (file descriptors, etc.) but also have their own stack for their own data. Sometimes there is a need for process-wide data specific to a given thread. Imagine a name of the thread in execution or something like that. The traditional <trademark class=\"registered\">UNIX</trademark> threading API, <application>pthreads</application> provides a way to do it via <citerefentry><refentrytitle>pthread_key_create</refentrytitle><manvolnum>3</manvolnum></citerefentry>, <citerefentry><refentrytitle>pthread_setspecific</refentrytitle><manvolnum>3</manvolnum></citerefentry> and <citerefentry><refentrytitle>pthread_getspecific</refentrytitle><manvolnum>3</manvolnum></citerefentry> where a thread can create a key to the thread local data and using <citerefentry><refentrytitle>pthread_getspecific</refentrytitle><manvolnum>3</manvolnum></citerefentry> or <citerefentry><refentrytitle>pthread_getspecific</refentrytitle><manvolnum>3</manvolnum></citerefentry> to manipulate those data. You can easily see that this is not the most comfortable way this could be accomplished. So various producers of C/C++ compilers introduced a better way. They defined a new modifier keyword thread that specifies that a variable is thread specific. A new method of accessing such variables was developed as well (at least on i386). The <application>pthreads</application> method tends to be implemented in userspace as a trivial lookup table. The performance of such a solution is not very good. So the new method uses (on i386) segment registers to address a segment, where TLS area is stored so the actual accessing of a thread variable is just appending the segment register to the address thus addressing via it. The segment registers are usually <varname>%gs</varname> and <varname>%fs</varname> acting like segment selectors. Every thread has its own area where the thread local data are stored and the segment must be loaded on every context switch. This method is very fast and used almost exclusively in the whole i386 <trademark class=\"registered\">UNIX</trademark> world. Both FreeBSD and <trademark class=\"registered\">Linux</trademark> implement this approach and it yields very good results. The only drawback is the need to reload the segment on every context switch which can slowdown context switches. FreeBSD tries to avoid this overhead by using only 1 segment descriptor for this while <trademark class=\"registered\">Linux</trademark> uses 3. Interesting thing is that almost nothing uses more than 1 descriptor (only <application>Wine</application> seems to use 2) so <trademark class=\"registered\">Linux</trademark> pays this unnecessary price for context switches."
msgstr ""

#. (itstool) path: sect3/title
#: article.translate.xml:1864
msgid "Segments on i386"
msgstr ""

#. (itstool) path: sect3/para
#: article.translate.xml:1866
msgid "The i386 architecture implements the so called segments. A segment is a description of an area of memory. The base address (bottom) of the memory area, the end of it (ceiling), type, protection, etc. The memory described by a segment can be accessed using segment selector registers (<varname>%cs</varname>, <varname>%ds</varname>, <varname>%ss</varname>, <varname>%es</varname>, <varname>%fs</varname>, <varname>%gs</varname>). For example let us suppose we have a segment which base address is 0x1234 and length and this code:"
msgstr ""

#. (itstool) path: sect3/programlisting
#: article.translate.xml:1877
#, no-wrap
msgid ""
"mov %edx,%gs:0x10"
msgstr ""

#. (itstool) path: sect3/para
#: article.translate.xml:1879
msgid "This will load the content of the <varname>%edx</varname> register into memory location 0x1244. Some segment registers have a special use, for example <varname>%cs</varname> is used for code segment and <varname>%ss</varname> is used for stack segment but <varname>%fs</varname> and <varname>%gs</varname> are generally unused. Segments are either stored in a global GDT table or in a local LDT table. LDT is accessed via an entry in the GDT. The LDT can store more types of segments. LDT can be per process. Both tables define up to 8191 entries."
msgstr ""

#. (itstool) path: sect3/title
#: article.translate.xml:1893
msgid "Implementation on <trademark class=\"registered\">Linux</trademark> i386"
msgstr ""

#. (itstool) path: sect3/para
#: article.translate.xml:1895
msgid "There are two main ways of setting up TLS in <trademark class=\"registered\">Linux</trademark>. It can be set when cloning a process using the <function>clone</function> syscall or it can call <function>set_thread_area</function>. When a process passes <literal>CLONE_SETTLS</literal> flag to <function>clone</function>, the kernel expects the memory pointed to by the <varname>%esi</varname> register a <trademark class=\"registered\">Linux</trademark> user space representation of a segment, which gets translated to the machine representation of a segment and loaded into a GDT slot. The GDT slot can be specified with a number or -1 can be used meaning that the system itself should choose the first free slot. In practice, the vast majority of programs use only one TLS entry and does not care about the number of the entry. We exploit this in the emulation and in fact depend on it."
msgstr ""

#. (itstool) path: sect3/title
#: article.translate.xml:1913
msgid "Emulation of <trademark class=\"registered\">Linux</trademark> TLS"
msgstr ""

#. (itstool) path: sect4/title
#: article.translate.xml:1916
msgid "i386"
msgstr ""

#. (itstool) path: sect4/para
#: article.translate.xml:1918
msgid "Loading of TLS for the current thread happens by calling <function>set_thread_area</function> while loading TLS for a second process in <function>clone</function> is done in the separate block in <function>clone</function>. Those two functions are very similar. The only difference being the actual loading of the GDT segment, which happens on the next context switch for the newly created process while <function>set_thread_area</function> must load this directly. The code basically does this. It copies the <trademark class=\"registered\">Linux</trademark> form segment descriptor from the userland. The code checks for the number of the descriptor but because this differs between FreeBSD and <trademark class=\"registered\">Linux</trademark> we fake it a little. We only support indexes of 6, 3 and -1. The 6 is genuine <trademark class=\"registered\">Linux</trademark> number, 3 is genuine FreeBSD one and -1 means autoselection. Then we set the descriptor number to constant 3 and copy out this to the userspace. We rely on the userspace process using the number from the descriptor but this works most of the time (have never seen a case where this did not work) as the userspace process typically passes in 1. Then we convert the descriptor from the <trademark class=\"registered\">Linux</trademark> form to a machine dependant form (i.e. operating system independent form) and copy this to the FreeBSD defined segment descriptor. Finally we can load it. We assign the descriptor to threads PCB (process control block) and load the <varname>%gs</varname> segment using <function>load_gs</function>. This loading must be done in a critical section so that nothing can interrupt us. The <literal>CLONE_SETTLS</literal> case works exactly like this just the loading using <function>load_gs</function> is not performed. The segment used for this (segment number 3) is shared for this use between FreeBSD processes and <trademark class=\"registered\">Linux</trademark> processes so the <trademark class=\"registered\">Linux</trademark> emulation layer does not add any overhead over plain FreeBSD."
msgstr ""

#. (itstool) path: sect4/title
#: article.translate.xml:1955
msgid "amd64"
msgstr ""

#. (itstool) path: sect4/para
#: article.translate.xml:1957
msgid "The amd64 implementation is similar to the i386 one but there was initially no 32bit segment descriptor used for this purpose (hence not even native 32bit TLS users worked) so we had to add such a segment and implement its loading on every context switch (when a flag signaling use of 32bit is set). Apart from this the TLS loading is exactly the same just the segment numbers are different and the descriptor format and the loading differs slightly."
msgstr ""

#. (itstool) path: sect2/title
#: article.translate.xml:1971
msgid "Futexes"
msgstr ""

#. (itstool) path: sect3/title
#: article.translate.xml:1974
msgid "Introduction to synchronization"
msgstr ""

#. (itstool) path: sect3/para
#: article.translate.xml:1976
msgid "Threads need some kind of synchronization and <trademark class=\"registered\">POSIX</trademark> provides some of them: mutexes for mutual exclusion, read-write locks for mutual exclusion with biased ratio of reads and writes and condition variables for signaling a status change. It is interesting to note that <trademark class=\"registered\">POSIX</trademark> threading API lacks support for semaphores. Those synchronization routines implementations are heavily dependant on the type threading support we have. In pure 1:M (userspace) model the implementation can be solely done in userspace and thus be very fast (the condition variables will probably end up being implemented using signals, i.e. not fast) and simple. In 1:1 model, the situation is also quite clear - the threads must be synchronized using kernel facilities (which is very slow because a syscall must be performed). The mixed M:N scenario just combines the first and second approach or rely solely on kernel. Threads synchronization is a vital part of thread-enabled programming and its performance can affect resulting program a lot. Recent benchmarks on FreeBSD operating system showed that an improved sx_lock implementation yielded 40% speedup in <firstterm>ZFS</firstterm> (a heavy sx user), this is in-kernel stuff but it shows clearly how important the performance of synchronization primitives is."
msgstr ""

#. (itstool) path: sect3/para
#: article.translate.xml:2000
msgid "Threaded programs should be written with as little contention on locks as possible. Otherwise, instead of doing useful work the thread just waits on a lock. Because of this, the most well written threaded programs show little locks contention."
msgstr ""

#. (itstool) path: sect3/title
#: article.translate.xml:2008
msgid "Futexes introduction"
msgstr ""

#. (itstool) path: sect3/para
#: article.translate.xml:2010
msgid "<trademark class=\"registered\">Linux</trademark> implements 1:1 threading, i.e. it has to use in-kernel synchronization primitives. As stated earlier, well written threaded programs have little lock contention. So a typical sequence could be performed as two atomic increase/decrease mutex reference counter, which is very fast, as presented by the following example:"
msgstr ""

#. (itstool) path: sect3/programlisting
#: article.translate.xml:2017
#, no-wrap
msgid ""
"pthread_mutex_lock(&amp;mutex);\n"
"....\n"
"pthread_mutex_unlock(&amp;mutex);"
msgstr ""

#. (itstool) path: sect3/para
#: article.translate.xml:2021
msgid "1:1 threading forces us to perform two syscalls for those mutex calls, which is very slow."
msgstr ""

#. (itstool) path: sect3/para
#: article.translate.xml:2024
msgid "The solution <trademark class=\"registered\">Linux</trademark> 2.6 implements is called futexes. Futexes implement the check for contention in userspace and call kernel primitives only in a case of contention. Thus the typical case takes place without any kernel intervention. This yields reasonably fast and flexible synchronization primitives implementation."
msgstr ""

#. (itstool) path: sect3/title
#: article.translate.xml:2033
msgid "Futex API"
msgstr ""

#. (itstool) path: sect3/para
#: article.translate.xml:2035
msgid "The futex syscall looks like this:"
msgstr ""

#. (itstool) path: sect3/programlisting
#: article.translate.xml:2037
#, no-wrap
msgid ""
"int futex(void *uaddr, int op, int val, struct timespec *timeout, void *uaddr2, int val3);"
msgstr ""

#. (itstool) path: sect3/para
#: article.translate.xml:2039
msgid "In this example <varname>uaddr</varname> is an address of the mutex in userspace, <varname>op</varname> is an operation we are about to perform and the other parameters have per-operation meaning."
msgstr ""

#. (itstool) path: sect3/para
#: article.translate.xml:2044
msgid "Futexes implement the following operations:"
msgstr ""

#. (itstool) path: listitem/para
#: article.translate.xml:2048
msgid "<literal>FUTEX_WAIT</literal>"
msgstr ""

#. (itstool) path: listitem/para
#: article.translate.xml:2051
msgid "<literal>FUTEX_WAKE</literal>"
msgstr ""

#. (itstool) path: listitem/para
#: article.translate.xml:2054
msgid "<literal>FUTEX_FD</literal>"
msgstr ""

#. (itstool) path: listitem/para
#: article.translate.xml:2057
msgid "<literal>FUTEX_REQUEUE</literal>"
msgstr ""

#. (itstool) path: listitem/para
#: article.translate.xml:2060
msgid "<literal>FUTEX_CMP_REQUEUE</literal>"
msgstr ""

#. (itstool) path: listitem/para
#: article.translate.xml:2063
msgid "<literal>FUTEX_WAKE_OP</literal>"
msgstr ""

#. (itstool) path: sect4/title
#: article.translate.xml:2068
msgid "FUTEX_WAIT"
msgstr ""

#. (itstool) path: sect4/para
#: article.translate.xml:2070
msgid "This operation verifies that on address <varname>uaddr</varname> the value <varname>val</varname> is written. If not, <literal>EWOULDBLOCK</literal> is returned, otherwise the thread is queued on the futex and gets suspended. If the argument <varname>timeout</varname> is non-zero it specifies the maximum time for the sleeping, otherwise the sleeping is infinite."
msgstr ""

#. (itstool) path: sect4/title
#: article.translate.xml:2081
msgid "FUTEX_WAKE"
msgstr ""

#. (itstool) path: sect4/para
#: article.translate.xml:2083
msgid "This operation takes a futex at <varname>uaddr</varname> and wakes up <varname>val</varname> first futexes queued on this futex."
msgstr ""

#. (itstool) path: sect4/title
#: article.translate.xml:2090
msgid "FUTEX_FD"
msgstr ""

#. (itstool) path: sect4/para
#: article.translate.xml:2092
msgid "This operations associates a file descriptor with a given futex."
msgstr ""

#. (itstool) path: sect4/title
#: article.translate.xml:2097
msgid "FUTEX_REQUEUE"
msgstr ""

#. (itstool) path: sect4/para
#: article.translate.xml:2099
msgid "This operation takes <varname>val</varname> threads queued on futex at <varname>uaddr</varname>, wakes them up, and takes <varname>val2</varname> next threads and requeues them on futex at <varname>uaddr2</varname>."
msgstr ""

#. (itstool) path: sect4/title
#: article.translate.xml:2107
msgid "FUTEX_CMP_REQUEUE"
msgstr ""

#. (itstool) path: sect4/para
#: article.translate.xml:2109
msgid "This operation does the same as <literal>FUTEX_REQUEUE</literal> but it checks that <varname>val3</varname> equals to <varname>val</varname> first."
msgstr ""

#. (itstool) path: sect4/title
#: article.translate.xml:2116
msgid "FUTEX_WAKE_OP"
msgstr ""

#. (itstool) path: sect4/para
#: article.translate.xml:2118
msgid "This operation performs an atomic operation on <varname>val3</varname> (which contains coded some other value) and <varname>uaddr</varname>. Then it wakes up <varname>val</varname> threads on futex at <varname>uaddr</varname> and if the atomic operation returned a positive number it wakes up <varname>val2</varname> threads on futex at <varname>uaddr2</varname>."
msgstr ""

#. (itstool) path: sect4/para
#: article.translate.xml:2127
msgid "The operations implemented in <literal>FUTEX_WAKE_OP</literal>:"
msgstr ""

#. (itstool) path: listitem/para
#: article.translate.xml:2132
msgid "<literal>FUTEX_OP_SET</literal>"
msgstr ""

#. (itstool) path: listitem/para
#: article.translate.xml:2135
msgid "<literal>FUTEX_OP_ADD</literal>"
msgstr ""

#. (itstool) path: listitem/para
#: article.translate.xml:2138
msgid "<literal>FUTEX_OP_OR</literal>"
msgstr ""

#. (itstool) path: listitem/para
#: article.translate.xml:2141
msgid "<literal>FUTEX_OP_AND</literal>"
msgstr ""

#. (itstool) path: listitem/para
#: article.translate.xml:2144
msgid "<literal>FUTEX_OP_XOR</literal>"
msgstr ""

#. (itstool) path: note/para
#: article.translate.xml:2149
msgid "There is no <varname>val2</varname> parameter in the futex prototype. The <varname>val2</varname> is taken from the <varname>struct timespec *timeout</varname> parameter for operations <literal>FUTEX_REQUEUE</literal>, <literal>FUTEX_CMP_REQUEUE</literal> and <literal>FUTEX_WAKE_OP</literal>."
msgstr ""

#. (itstool) path: sect3/title
#: article.translate.xml:2161
msgid "Futex emulation in FreeBSD"
msgstr ""

#. (itstool) path: sect3/para
#: article.translate.xml:2163
msgid "The futex emulation in FreeBSD is taken from NetBSD and further extended by us. It is placed in <filename>linux_futex.c</filename> and <filename>linux_futex.h</filename> files. The <literal>futex</literal> structure looks like:"
msgstr ""

#. (itstool) path: sect3/programlisting
#: article.translate.xml:2169
#, no-wrap
msgid ""
"struct futex {\n"
"  void *f_uaddr;\n"
"  int f_refcount;\n"
"\n"
"  LIST_ENTRY(futex) f_list;\n"
"\n"
"  TAILQ_HEAD(lf_waiting_paroc, waiting_proc) f_waiting_proc;\n"
"};"
msgstr ""

#. (itstool) path: sect3/para
#: article.translate.xml:2178
msgid "And the structure <literal>waiting_proc</literal> is:"
msgstr ""

#. (itstool) path: sect3/programlisting
#: article.translate.xml:2181
#, no-wrap
msgid ""
"struct waiting_proc {\n"
"\n"
"  struct thread *wp_t;\n"
"\n"
"  struct futex *wp_new_futex;\n"
"\n"
"  TAILQ_ENTRY(waiting_proc) wp_list;\n"
"};"
msgstr ""

#. (itstool) path: sect4/title
#: article.translate.xml:2191
msgid "futex_get / futex_put"
msgstr ""

#. (itstool) path: sect4/para
#: article.translate.xml:2193
msgid "A futex is obtained using the <function>futex_get</function> function, which searches a linear list of futexes and returns the found one or creates a new futex. When releasing a futex from the use we call the <function>futex_put</function> function, which decreases a reference counter of the futex and if the refcount reaches zero it is released."
msgstr ""

#. (itstool) path: sect4/title
#: article.translate.xml:2203
msgid "futex_sleep"
msgstr ""

#. (itstool) path: sect4/para
#: article.translate.xml:2205
msgid "When a futex queues a thread for sleeping it creates a <literal>working_proc</literal> structure and puts this structure to the list inside the futex structure then it just performs a <citerefentry><refentrytitle>tsleep</refentrytitle><manvolnum>9</manvolnum></citerefentry> to suspend the thread. The sleep can be timed out. After <citerefentry><refentrytitle>tsleep</refentrytitle><manvolnum>9</manvolnum></citerefentry> returns (the thread was woken up or it timed out) the <literal>working_proc</literal> structure is removed from the list and is destroyed. All this is done in the <function>futex_sleep</function> function. If we got woken up from <function>futex_wake</function> we have <varname>wp_new_futex</varname> set so we sleep on it. This way the actual requeueing is done in this function."
msgstr ""

#. (itstool) path: sect4/title
#: article.translate.xml:2221
msgid "futex_wake"
msgstr ""

#. (itstool) path: sect4/para
#: article.translate.xml:2223
msgid "Waking up a thread sleeping on a futex is performed in the <function>futex_wake</function> function. First in this function we mimic the strange <trademark class=\"registered\">Linux</trademark> behavior, where it wakes up N threads for all operations, the only exception is that the REQUEUE operations are performed on N+1 threads. But this usually does not make any difference as we are waking up all threads. Next in the function in the loop we wake up n threads, after this we check if there is a new futex for requeueing. If so, we requeue up to n2 threads on the new futex. This cooperates with <function>futex_sleep</function>."
msgstr ""

#. (itstool) path: sect4/title
#: article.translate.xml:2237
msgid "futex_wake_op"
msgstr ""

#. (itstool) path: sect4/para
#: article.translate.xml:2239
msgid "The <literal>FUTEX_WAKE_OP</literal> operation is quite complicated. First we obtain two futexes at addresses <varname>uaddr</varname> and <varname>uaddr2</varname> then we perform the atomic operation using <varname>val3</varname> and <varname>uaddr2</varname>. Then <varname>val</varname> waiters on the first futex is woken up and if the atomic operation condition holds we wake up <varname>val2</varname> (i.e. <varname>timeout</varname>) waiter on the second futex."
msgstr ""

#. (itstool) path: sect4/title
#: article.translate.xml:2252
msgid "futex atomic operation"
msgstr ""

#. (itstool) path: sect4/para
#: article.translate.xml:2254
msgid "The atomic operation takes two parameters <varname>encoded_op</varname> and <varname>uaddr</varname>. The encoded operation encodes the operation itself, comparing value, operation argument, and comparing argument. The pseudocode for the operation is like this one:"
msgstr ""

#. (itstool) path: sect4/programlisting
#: article.translate.xml:2261
#, no-wrap
msgid ""
"oldval = *uaddr2\n"
"*uaddr2 = oldval OP oparg"
msgstr ""

#. (itstool) path: sect4/para
#: article.translate.xml:2264
msgid "And this is done atomically. First a copying in of the number at <varname>uaddr</varname> is performed and the operation is done. The code handles page faults and if no page fault occurs <varname>oldval</varname> is compared to <varname>cmparg</varname> argument with cmp comparator."
msgstr ""

#. (itstool) path: sect4/title
#: article.translate.xml:2273
msgid "Futex locking"
msgstr ""

#. (itstool) path: sect4/para
#: article.translate.xml:2275
msgid "Futex implementation uses two lock lists protecting <function>sx_lock</function> and global locks (either Giant or another <function>sx_lock</function>). Every operation is performed locked from the start to the very end."
msgstr ""

#. (itstool) path: sect2/title
#: article.translate.xml:2285
msgid "Various syscalls implementation"
msgstr ""

#. (itstool) path: sect2/para
#: article.translate.xml:2287
msgid "In this section I am going to describe some smaller syscalls that are worth mentioning because their implementation is not obvious or those syscalls are interesting from other point of view."
msgstr ""

#. (itstool) path: sect3/title
#: article.translate.xml:2293
msgid "*at family of syscalls"
msgstr ""

#. (itstool) path: sect3/para
#: article.translate.xml:2295
msgid "During development of <trademark class=\"registered\">Linux</trademark> 2.6.16 kernel, the *at syscalls were added. Those syscalls (<function>openat</function> for example) work exactly like their at-less counterparts with the slight exception of the <varname>dirfd</varname> parameter. This parameter changes where the given file, on which the syscall is to be performed, is. When the <varname>filename</varname> parameter is absolute <varname>dirfd</varname> is ignored but when the path to the file is relative, it comes to the play. The <varname>dirfd</varname> parameter is a directory relative to which the relative pathname is checked. The <varname>dirfd</varname> parameter is a file descriptor of some directory or <literal>AT_FDCWD</literal>. So for example the <function>openat</function> syscall can be like this:"
msgstr ""

#. (itstool) path: sect3/programlisting
#: article.translate.xml:2311
#, no-wrap
msgid ""
"file descriptor 123 = /tmp/foo/, current working directory = /tmp/\n"
"\n"
"openat(123, /tmp/bah\\, flags, mode)\t/* opens /tmp/bah */\n"
"openat(123, bah\\, flags, mode)\t\t/* opens /tmp/foo/bah */\n"
"openat(AT_FDWCWD, bah\\, flags, mode)\t/* opens /tmp/bah */\n"
"openat(stdio, bah\\, flags, mode)\t/* returns error because stdio is not a directory */"
msgstr ""

#. (itstool) path: sect3/para
#: article.translate.xml:2318
msgid "This infrastructure is necessary to avoid races when opening files outside the working directory. Imagine that a process consists of two threads, thread A and thread B. Thread A issues <literal>open(./tmp/foo/bah., flags, mode)</literal> and before returning it gets preempted and thread B runs. Thread B does not care about the needs of thread A and renames or removes <filename>/tmp/foo/</filename>. We got a race. To avoid this we can open <filename>/tmp/foo</filename> and use it as <varname>dirfd</varname> for <function>openat</function> syscall. This also enables user to implement per-thread working directories."
msgstr ""

#. (itstool) path: sect3/para
#: article.translate.xml:2332
msgid "<trademark class=\"registered\">Linux</trademark> family of *at syscalls contains: <function>linux_openat</function>, <function>linux_mkdirat</function>, <function>linux_mknodat</function>, <function>linux_fchownat</function>, <function>linux_futimesat</function>, <function>linux_fstatat64</function>, <function>linux_unlinkat</function>, <function>linux_renameat</function>, <function>linux_linkat</function>, <function>linux_symlinkat</function>, <function>linux_readlinkat</function>, <function>linux_fchmodat</function> and <function>linux_faccessat</function>. All these are implemented using the modified <citerefentry><refentrytitle>namei</refentrytitle><manvolnum>9</manvolnum></citerefentry> routine and simple wrapping layer."
msgstr ""

#. (itstool) path: sect4/title
#: article.translate.xml:2350
msgid "Implementation"
msgstr ""

#. (itstool) path: sect4/para
#: article.translate.xml:2352
msgid "The implementation is done by altering the <citerefentry><refentrytitle>namei</refentrytitle><manvolnum>9</manvolnum></citerefentry> routine (described above) to take additional parameter <varname>dirfd</varname> in its <literal>nameidata</literal> structure, which specifies the starting point of the pathname lookup instead of using the current working directory every time. The resolution of <varname>dirfd</varname> from file descriptor number to a vnode is done in native *at syscalls. When <varname>dirfd</varname> is <literal>AT_FDCWD</literal> the <varname>dvp</varname> entry in <literal>nameidata</literal> structure is <literal>NULL</literal> but when <varname>dirfd</varname> is a different number we obtain a file for this file descriptor, check whether this file is valid and if there is vnode attached to it then we get a vnode. Then we check this vnode for being a directory. In the actual <citerefentry><refentrytitle>namei</refentrytitle><manvolnum>9</manvolnum></citerefentry> routine we simply substitute the <varname>dvp</varname> vnode for <varname>dp</varname> variable in the <citerefentry><refentrytitle>namei</refentrytitle><manvolnum>9</manvolnum></citerefentry> function, which determines the starting point. The <citerefentry><refentrytitle>namei</refentrytitle><manvolnum>9</manvolnum></citerefentry> is not used directly but via a trace of different functions on various levels. For example the <function>openat</function> goes like this:"
msgstr ""

#. (itstool) path: sect4/programlisting
#: article.translate.xml:2376
#, no-wrap
msgid ""
"openat() --&gt; kern_openat() --&gt; vn_open() -&gt; namei()"
msgstr ""

#. (itstool) path: sect4/para
#: article.translate.xml:2378
msgid "For this reason <function>kern_open</function> and <function>vn_open</function> must be altered to incorporate the additional <varname>dirfd</varname> parameter. No compat layer is created for those because there are not many users of this and the users can be easily converted. This general implementation enables FreeBSD to implement their own *at syscalls. This is being discussed right now."
msgstr ""

#. (itstool) path: sect3/title
#: article.translate.xml:2390
msgid "Ioctl"
msgstr ""

#. (itstool) path: sect3/para
#: article.translate.xml:2392
msgid "The ioctl interface is quite fragile due to its generality. We have to bear in mind that devices differ between <trademark class=\"registered\">Linux</trademark> and FreeBSD so some care must be applied to do ioctl emulation work right. The ioctl handling is implemented in <filename>linux_ioctl.c</filename>, where <function>linux_ioctl</function> function is defined. This function simply iterates over sets of ioctl handlers to find a handler that implements a given command. The ioctl syscall has three parameters, the file descriptor, command and an argument. The command is a 16-bit number, which in theory is divided into high 8 bits determining class of the ioctl command and low 8 bits, which are the actual command within the given set. The emulation takes advantage of this division. We implement handlers for each set, like <function>sound_handler</function> or <function>disk_handler</function>. Each handler has a maximum command and a minimum command defined, which is used for determining what handler is used. There are slight problems with this approach because <trademark class=\"registered\">Linux</trademark> does not use the set division consistently so sometimes ioctls for a different set are inside a set they should not belong to (SCSI generic ioctls inside cdrom set, etc.). FreeBSD currently does not implement many <trademark class=\"registered\">Linux</trademark> ioctls (compared to NetBSD, for example) but the plan is to port those from NetBSD. The trend is to use <trademark class=\"registered\">Linux</trademark> ioctls even in the native FreeBSD drivers because of the easy porting of applications."
msgstr ""

#. (itstool) path: sect3/title
#: article.translate.xml:2422
msgid "Debugging"
msgstr ""

#. (itstool) path: sect3/para
#: article.translate.xml:2424
msgid "Every syscall should be debuggable. For this purpose we introduce a small infrastructure. We have the ldebug facility, which tells whether a given syscall should be debugged (settable via a sysctl). For printing we have LMSG and ARGS macros. Those are used for altering a printable string for uniform debugging messages."
msgstr ""

#. (itstool) path: sect1/title
#: article.translate.xml:2435
msgid "Conclusion"
msgstr ""

#. (itstool) path: sect2/title
#: article.translate.xml:2438
msgid "Results"
msgstr ""

#. (itstool) path: sect2/para
#: article.translate.xml:2440
msgid "As of April 2007 the <trademark class=\"registered\">Linux</trademark> emulation layer is capable of emulating the <trademark class=\"registered\">Linux</trademark> 2.6.16 kernel quite well. The remaining problems concern futexes, unfinished *at family of syscalls, problematic signals delivery, missing <function>epoll</function> and <function>inotify</function> and probably some bugs we have not discovered yet. Despite this we are capable of running basically all the <trademark class=\"registered\">Linux</trademark> programs included in FreeBSD Ports Collection with Fedora Core 4 at 2.6.16 and there are some rudimentary reports of success with Fedora Core 6 at 2.6.16. The Fedora Core 6 linux_base was recently committed enabling some further testing of the emulation layer and giving us some more hints where we should put our effort in implementing missing stuff."
msgstr ""

#. (itstool) path: sect2/para
#: article.translate.xml:2455
msgid "We are able to run the most used applications like <package>www/linux-firefox</package>, <package>www/linux-opera</package>, <package>net-im/skype</package> and some games from the Ports Collection. Some of the programs exhibit bad behavior under 2.6 emulation but this is currently under investigation and hopefully will be fixed soon. The only big application that is known not to work is the <trademark class=\"registered\">Linux</trademark> <trademark>Java</trademark> Development Kit and this is because of the requirement of <function>epoll</function> facility which is not directly related to the <trademark class=\"registered\">Linux</trademark> kernel 2.6."
msgstr ""

#. (itstool) path: sect2/para
#: article.translate.xml:2467
msgid "We hope to enable 2.6.16 emulation by default some time after FreeBSD 7.0 is released at least to expose the 2.6 emulation parts for some wider testing. Once this is done we can switch to Fedora Core 6 linux_base, which is the ultimate plan."
msgstr ""

#. (itstool) path: sect2/title
#: article.translate.xml:2475
msgid "Future work"
msgstr ""

#. (itstool) path: sect2/para
#: article.translate.xml:2477
msgid "Future work should focus on fixing the remaining issues with futexes, implement the rest of the *at family of syscalls, fix the signal delivery and possibly implement the <function>epoll</function> and <function>inotify</function> facilities."
msgstr ""

#. (itstool) path: sect2/para
#: article.translate.xml:2483
msgid "We hope to be able to run the most important programs flawlessly soon, so we will be able to switch to the 2.6 emulation by default and make the Fedora Core 6 the default linux_base because our currently used Fedora Core 4 is not supported any more."
msgstr ""

#. (itstool) path: sect2/para
#: article.translate.xml:2489
msgid "The other possible goal is to share our code with NetBSD and DragonflyBSD. NetBSD has some support for 2.6 emulation but its far from finished and not really tested. DragonflyBSD has expressed some interest in porting the 2.6 improvements."
msgstr ""

#. (itstool) path: sect2/para
#: article.translate.xml:2495
msgid "Generally, as <trademark class=\"registered\">Linux</trademark> develops we would like to keep up with their development, implementing newly added syscalls. Splice comes to mind first. Some already implemented syscalls are also heavily crippled, for example <function>mremap</function> and others. Some performance improvements can also be made, finer grained locking and others."
msgstr ""

#. (itstool) path: sect2/title
#: article.translate.xml:2505
msgid "Team"
msgstr ""

#. (itstool) path: sect2/para
#: article.translate.xml:2507
msgid "I cooperated on this project with (in alphabetical order):"
msgstr ""

#. (itstool) path: listitem/para
#: article.translate.xml:2512
msgid "John Baldwin <email>jhb@FreeBSD.org</email>"
msgstr ""

#. (itstool) path: listitem/para
#: article.translate.xml:2515
msgid "Konstantin Belousov <email>kib@FreeBSD.org</email>"
msgstr ""

#. (itstool) path: listitem/para
#: article.translate.xml:2518
msgid "Emmanuel Dreyfus"
msgstr ""

#. (itstool) path: listitem/para
#: article.translate.xml:2521
msgid "Scot Hetzel"
msgstr ""

#. (itstool) path: listitem/para
#: article.translate.xml:2524
msgid "Jung-uk Kim <email>jkim@FreeBSD.org</email>"
msgstr ""

#. (itstool) path: listitem/para
#: article.translate.xml:2527
msgid "Alexander Leidinger <email>netchild@FreeBSD.org</email>"
msgstr ""

#. (itstool) path: listitem/para
#: article.translate.xml:2530
msgid "Suleiman Souhlal <email>ssouhlal@FreeBSD.org</email>"
msgstr ""

#. (itstool) path: listitem/para
#: article.translate.xml:2533
msgid "Li Xiao"
msgstr ""

#. (itstool) path: listitem/para
#: article.translate.xml:2536
msgid "David Xu <email>davidxu@FreeBSD.org</email>"
msgstr ""

#. (itstool) path: sect2/para
#: article.translate.xml:2540
msgid "I would like to thank all those people for their advice, code reviews and general support."
msgstr ""

#. (itstool) path: sect1/title
#: article.translate.xml:2546
msgid "Literatures"
msgstr ""

#. (itstool) path: listitem/para
#: article.translate.xml:2550
msgid "Marshall Kirk McKusick - George V. Nevile-Neil. Design and Implementation of the FreeBSD operating system. Addison-Wesley, 2005."
msgstr ""

#. (itstool) path: listitem/para
#: article.translate.xml:2555
msgid "<uri xlink:href=\"https://tldp.org\">https://tldp.org</uri>"
msgstr ""

#. (itstool) path: listitem/para
#: article.translate.xml:2558
msgid "<uri xlink:href=\"https://www.kernel.org\">https://www.kernel.org</uri>"
msgstr ""

